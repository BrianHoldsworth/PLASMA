import STDLIB
    predef syscall, call, memset, getc, putc, puts, putln
    predef memset, memcpy
    predef heapmark, heapallocallign, heapalloc, heaprelease, heapavail
    byte MACHID
end

const FALSE = 0
const TRUE  = not FALSE
//
// Octant beam parameters
//
const beamdepth = 10
const octpts    = 52
//
// X offsets
//
byte[] xbeam
byte = 0
byte = 0, 1
byte = 0, 1
byte = 0, 1, 2
byte = 0, 1, 2, 3
byte = 0, 1, 2, 2, 3
byte = 0, 1, 2, 3, 4
byte = 0, 1, 2, 3, 4, 5
byte = 0, 1, 2, 3, 4, 4, 5
byte = 0, 1, 2, 3, 4, 5, 6, 6
byte = 0, 1, 2, 3, 3, 4, 5, 5, 6, 7
//
// Y offest
//
byte[] ybeam
byte = 0
byte = 1, 1
byte = 2, 2
byte = 3, 3, 2
byte = 4, 4, 3, 3
byte = 5, 5, 5, 4, 4
byte = 6, 6, 6, 5, 4
byte = 7, 7, 7, 6, 5, 5
byte = 8, 8, 8, 7, 7, 6, 6
byte = 9, 9, 9, 8, 8, 7, 7, 6
byte = 10, 10, 10, 10, 9, 9, 9, 8, 8, 7
//
// Visibilty parent indeces
//
byte[] vbeam
byte = 0
byte = 0, 0
byte = 1, 1
byte = 3, 4, 2
byte = 5, 6, 4, 7
byte = 8, 9, 9, 6, 10
byte = 12, 13, 14, 15, 11
byte = 17, 18, 19, 14, 16, 21
byte = 22, 23, 24, 19, 25, 20, 26
byte = 28, 29, 30, 24, 31, 33, 34, 27
byte = 35, 36, 37, 37, 38, 38, 39, 32, 40, 42
//
// Depth level indeces
//
byte dbeam = 0, 2, 4, 7, 11, 16, 21, 27, 34, 42, 52

const maprows = 21
const mapcols = 32
const WALL    = '#'
const VISWALL = $A3 // '#' | $80
const FLOOR   = '.'

byte[] map
byte = "###############################"
byte = "#.................#...........#"
byte = "#.............###.#.........#.#"
byte = "#......##.......#.#.........#.#"
byte = "#......##.......#.#.........#.#"
byte = "#...............#...........#.#"
byte = "#...............#...........#.#"
byte = "#......##.......#.#.........#.#"
byte = "#......##.......#.#.........#.#"
byte = "#...............#.#.........#.#"
byte = "#...............#.###########.#"
byte = "#......##.......#.#...........#"
byte = "#......##.......#.#......######"
byte = "#...............#.#......#....#"
byte = "#...............#.#......#....#"
byte = "#......##.......#.#......#....#"
byte = "#......##.......#.#......#....#"
byte = "#.#.............#.#......#....#"
byte = "#.###############.#......###..#"
byte = "#.................#...........#"
byte = "###############################"

word vismap

const xcentr = 20
const ycentr = 12

word[] screen
word = $400, $480, $500, $580, $600, $680, $700, $780
word = $428, $4A8, $528, $5A8, $628, $6A8, $728, $7A8
word = $450, $4D0, $550, $5D0, $650, $6D0, $750, $7D0

const SPEAKER = $C030

word xdir =  0,  1,  1,  1,  0, -1, -1, -1
word ydir = -1, -1,  0,  1,  1,  1,  0, -1
word xplayer = 5
word yplayer = 5
byte aplayer = 0
byte lamp    = 4
byte fov     = 1
byte vplayer = '^', '\\', '>', '/', 'v', '\\', '<', '/'

def home
    return call($FC58, 0, 0, 0, 0)
end

def gotoxy(x, y)
    ^$24 = x + ^$20
    return call($FB5B, y + ^$22, 0, 0, 0)
end

def ouch
  byte i, delay
  
  for i = 0 to 255
    ^SPEAKER
    for delay = 0 to 1
    next
  next
end

def drawmap(xorg, yorg, dir, light)
  byte[octpts] vispix
  byte o, l, tile, occlude
  word ymap, xmap, imap
  byte yscr, xscr

  //
  // Clear screen
  //
  home
  //
  // Draw background map
  //
  if light
  xmap = xorg - xcentr
  if xmap < 0
    l    = mapcols + xmap
    xscr = -xmap
    xmap = 0
  else
    l    = mapcols - xmap - 1
    xscr = 0
  fin
  if xscr + l > 40
    l    = 40 - xscr
  fin
  for yscr = 0 to 23
    ymap = yscr - ycentr + yorg
    if ymap >= 0 and ymap < maprows
      memcpy(screen[yscr] + xscr, vismap  + (ymap << 5) + xmap + 1, l)
    fin
  next
  //
  // Draw visible octants
  //
  for o = dir - fov - 1 to dir + fov
    memset(@vispix, dbeam[light], TRUE)
    when o & 7
      is 0
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg - ybeam[l]) << 5) + xorg + xbeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) =  tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap + 1] == WALL
                ^(vismap + imap + 1) = VISWALL
                screen.[ycentr - ybeam[l], xcentr + xbeam[l] + 1] = WALL
              fin
            fin
            screen.[ycentr - ybeam[l], xcentr + xbeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 1
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << 5) + xorg + ybeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap - mapcols] == WALL
                ^(vismap + imap - mapcols) = VISWALL
                screen.[ycentr - xbeam[l] - 1, xcentr + ybeam[l]] = WALL
              fin
            fin
            screen.[ycentr - xbeam[l], xcentr + ybeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 2
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << 5) + xorg + ybeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap + mapcols] == WALL
                ^(vismap + imap + mapcols) = VISWALL
                screen.[ycentr + xbeam[l] + 1, xcentr + ybeam[l]] = WALL
              fin
            fin
            screen.[ycentr + xbeam[l], xcentr + ybeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 3
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << 5) + xorg + xbeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap + 1] == WALL
                ^(vismap + imap + 1) = VISWALL
                screen.[ycentr + ybeam[l], xcentr + xbeam[l] + 1] = WALL
              fin
            fin
            screen.[ycentr + ybeam[l], xcentr + xbeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 4
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << 5) + xorg - xbeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap - 1] == WALL
                ^(vismap + imap - 1) = VISWALL
                screen.[ycentr + ybeam[l], xcentr - xbeam[l] - 1] = WALL
              fin
            fin
            screen.[ycentr + ybeam[l], xcentr - xbeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 5
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << 5) + xorg - ybeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap + mapcols] == WALL
                ^(vismap + imap + mapcols) = VISWALL
                screen.[ycentr + xbeam[l] + 1, xcentr - ybeam[l]] = WALL
              fin
            fin
            screen.[ycentr + xbeam[l], xcentr - ybeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 6
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << 5) + xorg - ybeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap - mapcols] == WALL
                ^(vismap + imap - mapcols) = VISWALL
                screen.[ycentr - xbeam[l] - 1, xcentr - ybeam[l]] = WALL
              fin
            fin
            screen.[ycentr - xbeam[l], xcentr - ybeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
      is 7
        for l = 1 to dbeam[light]
          if vispix[vbeam[l]]
            imap = ((yorg - ybeam[l]) << 5) + xorg - xbeam[l] + 1
            tile = map[imap]
            ^(vismap + imap) = tile | $80
            if tile <> FLOOR
              vispix[l] = FALSE
            else
              if map[imap - 1] == WALL
                ^(vismap + imap - 1) = VISWALL
                screen.[ycentr - ybeam[l], xcentr - xbeam[l] - 1] = WALL
              fin
            fin
            screen.[ycentr - ybeam[l], xcentr - xbeam[l]] = tile
          else
            vispix[l] = FALSE
          fin
        next
        break
    wend
  next
  gotoxy(xcentr, ycentr)
  putc(vplayer[dir])
  else
  gotoxy(xcentr, ycentr)
  putc('@')
  fin
  gotoxy(xcentr, ycentr)
end

def moveplayer(dir)
  xplayer = xplayer + dir * xdir[aplayer]
  yplayer = yplayer + dir * ydir[aplayer]
  if map[yplayer * mapcols + xplayer + 1] <> FLOOR
    xplayer = xplayer - dir * xdir[aplayer]
    yplayer = yplayer - dir * ydir[aplayer]
    ouch
  fin
end

vismap = heapalloc(maprows * mapcols)
memset(vismap, maprows * mapcols, $A0A0)
while TRUE
  drawmap(xplayer, yplayer, aplayer, lamp)
  when getc()
    is ','
    is '<'
      if fov > 0
        fov = fov - 1
      fin
      break
    is '.'
    is '>'
      if fov < 4
        fov = fov + 1
      fin
      break
    is '-'
      if lamp > 0
        lamp = lamp - 1
      fin
      break
    is '+'
      if lamp < beamdepth - 1
        lamp = lamp + 1
      fin
      break
    is 'i'
    is 'I'
      aplayer = 0
      moveplayer(1)
      break
    is 'j'
    is 'J'
      aplayer = 6
      moveplayer(1)
      break
    is 'k'
    is 'K'
      aplayer = 2
      moveplayer(1)
      break
    is 'm'
    is 'M'
      aplayer = 4
      moveplayer(1)
      break
    is 'q'
    is 'Q'
      moveplayer(1)
    is 'a'
    is 'A'
    is $0B
      moveplayer(1)
      break
    is 'z'
    is 'Z'
    is $0A
      moveplayer(-1)
      break
    is $08
      aplayer = (aplayer - 1) & 7
      break
    is $15
      aplayer = (aplayer + 1) & 7
      break
    is 'x'
    is 'X'
      return
  wend
loop
done
