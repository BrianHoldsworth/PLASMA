include "inc/cmdsys.plh"
include "inc/fileio.plh"
include "inc/args.plh"
include "inc/sdfat.plh"

const COPY_BUF_SIZE = 4096 // 4K
const COPY_BLK_SIZE = COPY_BUF_SIZE/512
const COPY_BLK_CNT  = COPY_BLK_SIZE-1
const DRIVE1 = $60 // drive 1, slot 6
const DRIVE2 = $D0 // drive 2, slot 6
const LOWER_DIFF = 'a' - 'A'

word arg, image
byte unit = DRIVE1

def putb(b)
    byte c
    c = ((b >> 4) & $0F) + '0'
    if c > '9'
        c = c + 7
    fin
    putc(c)
    c = (b & $0F) + '0'
    if c > '9'
        c = c + 7
    fin
    return putc(c)
end

def puti(i)
    word tt, th, h, t
    byte  p

    p =0
    if i < 0
        putc('-')
        i = -i
    fin
    tt = i / 10000
    i  = i % 10000
    th = i / 1000
    i  = i % 1000
    h  = i / 100
    i  = i % 100
    t  = i / 10
    i  = i % 10
    if tt > 0
        putc(tt + '0'); p = 1
    fin
    if p or th > 0
        putc(th + '0'); p = 1
    fin
    if p or h > 0
        putc(h + '0'); p = 1
    fin
    if p or t > 0
        putc(t + '0'); p = 1
    fin
    return putc(i + '0')
end

def charUpper(c)
    if c >= 'a' and c <= 'z'
        return c - LOWER_DIFF
    fin
    return c
end

def getYN(prompt)
    byte yn
    
    puts(prompt)
    yn = getc
    putln
    return yn == 'Y' or yn == 'y'
end

def bigFatWrite(buf, len)
    word xferLen, fatLen
    
    xferLen = 0
    repeat
        if len > MAX_FAT_BUF_SIZE
            fatLen = MAX_FAT_BUF_SIZE
        else
            fatLen = len
        fin
        fatLen = sdFAT:fileWrite(buf, fatLen)
        if fatLen > 0
            xferLen = xferLen + fatLen
            len     = len     - fatLen
            buf     = buf     + fatLen
        else
            len = 0
        fin
    until len == 0
    return xferLen
end

def fatReadImage(src, drv)
    word copyBuf, copyLen, freeAddr
    word blocknum, bufblk
    
    copyBuf = heapallocalign(COPY_BUF_SIZE, 8, @freeAddr)
    if not copyBuf
        puts("Not enough free memory!\n"); putln
        return -1
    fin
    //
    // Copy FAT image over one track at a time
    //
    if sdFAT:fileOpen(src, O_READ | O_WRITE | O_CREAT)
        if !drv; putc(7); fin
        for blocknum = 0 to 279 step COPY_BLK_SIZE
            if drv
                ^$24=^$20 // Move cursor to left edge
                puts("Reading blocks: "); puti(blocknum)
                    for bufblk = 0 to COPY_BLK_CNT
                        if readblock(drv, copyBuf + (bufblk << 9), blocknum + bufblk)
                            puts("Read disk error: $"); putb(perr); putln
                            break
                        fin
                    next
            fin
            copyLen = bigFatWrite(copyBuf, COPY_BUF_SIZE)
            if copyLen <> COPY_BUF_SIZE
                puts("Write image file error\n");
            fin
            if copyLen < COPY_BUF_SIZE or perr
                puts("Error creating image: "); puts(src); putln
                break
            fin
        next
        if !drv; putc(7);fin
        putln
        sdFAT:fileClose()
    else
        puts("Error opening image file:"); puts(src); putln
    fin
    heaprelease(freeAddr)
end

arg = argNext(argFirst)
if ^arg
    image = arg
    arg = argNext(arg)
    if ^arg 
        when ^(arg + 1)
            is '2' // Drive 2 option
                unit = DRIVE2
                break
            is 'T' // Test speed option
            is 't'
                unit = 0
                break
        wend
    fin
    if unit
        puts("Reading "); puts(image); puts(" from Drive "); putc((unit >> 7) + '1')
    else
        puts("Speed test writing 143K to SD card");
    fin
    if getYN("\nContinue? (Y/N)")
        fatReadImage(image, unit)
    fin
else
    puts("Read DSK image from floppy disk drive\n")
    puts("Usage: +FATREADDSK <DSK image file> [1,2,T]\n")
fin
done
