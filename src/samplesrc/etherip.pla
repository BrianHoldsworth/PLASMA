import stdlib
    predef syscall, call, memset, getc, gets, putc, puts, putln
    predef memset, memcpy, modaddr, modexec
    predef heapmark, heapallocalign, heapalloc, heaprelease
    byte MACHID
end
import uthernet
    predef MAC, writeEther, writevEther, readEther, readvEther, recvEther
end
//
// Max Ethernet frame size
//
const MAX_FRAME_SIZE = 1518
const BROADCAST_MAC  = $FFFF
const MAC_SIZE       = 6
//
// Ethernet header
//
struc t_ehdr
    byte[MAC_SIZE] ehdr_dstaddr
    byte[MAC_SIZE] ehdr_srcaddr
    word    ehdr_payload
end
const PAYLOAD_IP  = $0008 // BE format
const PAYLOAD_ARP = $0608 // BE format
//
// IP datagram header
//
const IP_SIZE = 4
struc t_ip
    byte ip_vers_hlen
    byte ip_service
    word ip_length
    word ip_id
    word ip_flags_fragofst
    byte ip_ttl
    byte ip_proto
    word ip_checksum
    byte[IP_SIZE] ip_src
    byte[IP_SIZE] ip_dst
    byte[]  ip_options
end
//
// ARP packet
//
const HW_ETHER    = $0100 // BE format
const ARP_PROTO   = $0008 // BE format
const ARP_REQST   = $0100 // BE format
const ARP_REPLY   = $0200 // BE format
struc t_arp
    word arp_hw
    word arp_proto
    byte arp_hlen
    byte arp_plen
    word arp_op
    byte[MAC_SIZE] arp_senderha
    byte[IP_SIZE] arp_senderip
    byte[MAC_SIZE] arp_targha
    byte[IP_SIZE] arp_targip
end
const t_earp = t_ehdr+t_arp
//
// Pre-configured ARP packet
//
byte[] ARP
byte[MAC_SIZE] dstMAC
byte[MAC_SIZE] srcMAC
word       = PAYLOAD_ARP
word       = HW_ETHER  // HW TYPE
word       = ARP_PROTO // PROTO TYPE
byte       = MAC_SIZE  // HLEN
byte       = IP_SIZE   // PLEN
word opARP             // OP
byte[MAC_SIZE] localha
byte[IP_SIZE ] localip  = 192,168,123,10
byte[MAC_SIZE] remoteha
byte[IP_SIZE]  remoteip = 192,168,123,1
//
// Defines for ASM routines
//
asm equates
	!SOURCE	"vmsrc/plvmzp.inc"
end
//
// ASM utility functions
//
// Swap bytes in word
//
asm swab
	LDA	ESTKL,X
	LDY	ESTKH,X
	STA	ESTKH,X
	STY	ESTKL,X
	RTS
end
//
// SUM BE format
// sum(BUF, LEN)
//
export asm sum
	LDY	#$00
	LDA	ESTKL+1,X
	STY	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STY	ESTKH+1,X
	STA	SRCH
	LSR	ESTKH,X	; CONVERT BYTE LEN TO WORD LEN
	LDA	ESTKL,X
	ROR
	ADC	#$00
	STA	ESTKL,X
	BEQ	CHKLP
	INC     ESTKH,X
CHKLP	LDA	(SRC),Y
	PHA
	INY
	BNE	+
	INC	SRCH
+	LDA	(SRC),Y
	CLC
	ADC	ESTKH+1,X
	STA	ESTKH+1,X
	PLA
	ADC	ESTKL+1,X
	STA	ESTKL+1,X
	INY
	BNE	+
    	INC	SRCH
+	DEC	ESTKL,X
	BNE	CHKLP
	DEC	ESTKH,X
	BNE	CHKLP
	INX
	RTS
end
//
// DEBUG
//
def putln
    return putc($0D)
end
def putb(hexb)
    return call($FDDA, hexb, 0, 0, 0)
end
def puth(hex)
    return call($F941, hex >> 8, hex, 0, 0)
end
def puti(i)
  if i < 0; putc('-'); i = -i; fin
  if i < 10
    putc(i + '0')
  else
    puti(i / 10)
    putc(i % 10 + '0')
  fin
end
def putha(haptr)
    byte i
    
    for i = 0 to 4
        putb(haptr->[i]); putc(':')
    next
    return putb(haptr->[i])
end
def putip(ipptr)
    byte i
    
    for i = 0 to 2
        puti(ipptr->[i]); putc('.')
    next
    return puti(ipptr->[i])
end
def dumparp(packet)
    puth(packet=>arp_hw); putln
    puth(packet=>arp_proto); putln
    putb(packet->arp_hlen); putln
    putb(packet->arp_plen); putln
    puth(packet=>arp_op); putln
    putha(packet + arp_senderha)
    putc('=')
    putip(packet + arp_senderip)
    putln
    putha(packet + arp_targha)
    putc('=')
    putip(packet + arp_targip)
    putln
end
def dumpehdr(packet)
    putha(packet + ehdr_dstaddr); putc(' ')
    putha(packet + ehdr_srcaddr); putc(' ')
    puth(packet=>ehdr_payload); putln
end
def dumpfrm(packet, len)
    word i

    if len > 64
        len = 64
    fin
    len = len - 1
    for i = 0 to len
        if (i & 7) == 0
	    putln
        else
	    putc(' ')
	fin
	putb(^(packet+i))
    next
    putln
end
//
// Write IP datagram
//
export def writeIP(dst, proto, packet)
end
//
// Read IP datagram
//
export def readIP(dst, proto, packet)
end
//
// Service incoming packets
//
def serviceIP
    word pkt, len

    len = recvEther
    if len
        len = len - t_ehdr
        when readEther(t_ehdr)=>ehdr_payload
            is PAYLOAD_IP
	        readEther(len)
	        break
            is PAYLOAD_ARP
	        pkt = readEther(len)
	        if pkt=>arp_op == ARP_REPLY
		    //
		    // Fill in ARP cache
		    //
		    memcpy(@remoteha, @pkt=>arp_senderha, 10) // copy ha and ip
		    putha(pkt+arp_senderha);putc('=');putip(pkt+arp_senderip);putln
		elsif pkt=>arp_op == ARP_REQST
		    //
		    // Is this a request for me?
		    //
		    if pkt=>arp_targip:0 == localip:0 and pkt=>arp_targip:2 == localip:2
		        memcpy(@dstMAC, pkt=>arp_senderha, MAC_SIZE)
		        memcpy(@remoteha, @pkt=>arp_senderha, 10) // copy ha and ip
		        opARP = ARP_REPLY
			writeEther(@ARP, t_earp)
                        putha(pkt+arp_senderha);putc('=');putip(pkt+arp_senderip);putln
		    fin
		else
		    dumparp(pkt)
		fin
		break
            otherwise
		pkt = readEther(len)
	        dumpehdr(pkt - t_ehdr)
		//dumpfrm(pkt, len)
        wend
    fin
end
//
// Start things off with an ARP request
//
memcpy(@srcMAC,  @MAC, MAC_SIZE)
memcpy(@localha, @MAC, MAC_SIZE)
memset(@dstMAC,   MAC_SIZE, BROADCAST_MAC)
memset(@remoteha, MAC_SIZE, 0)
opARP = ARP_REQST
writeEther(@ARP, t_earp)
repeat
    serviceIP
until ^$C000 > 127
^$C010
done