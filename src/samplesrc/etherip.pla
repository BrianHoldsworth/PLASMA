import STDLIB
    predef syscall, call, memset, getc, gets, putc, puts, putln
    predef memset, memcpy, modaddr, modexec
    predef heapmark, heapallocalign, heapalloc, heaprelease
    byte MACHID
end
//
// Ethernet adapter driver
//
byte etherlib = "UTHERNET", 0
struc t_edrvr
    word fillMAC
    word writeFrame
    word readFrame
    word recvFrame
end
word edrvr
//
// Ethernet packet header
//
struc t_ether
    byte[6] hwdst
    byte[6] hwsrc
    word    payload
end
//
// IP datagram header
//
const HW_ETHER = $0100 // BE format
const PROTO_IP = $0008 // BE format
struc t_ip
    byte ip_vers_hlen
    byte ip_service
    word ip_length
    word ip_id
    word ip_flags_fragofst
    byte ip_ttl
    byte ip_proto
    word ip_checksum
    byte[4] ip_src
    byte[4] ip_dst
    byte[]  ip_options
end
//
// ARP packet
//
const PAYLOAD_ARP = $0608 // BE format
const ARP_REQST   = $0100 // BE format
const ARP_REPLY   = $0200 // BE format
struc t_arp
    word arp_hw
    word arp_proto
    byte arp_hlen
    byte arp_plen
    word arp_op
    byte[6] arp_senderha
    byte[4] arp_senderip
    byte[6] arp_targha
    byte[4] arp_targip
end
//
// Broadcast address for Ethernet and IP
//
byte BCAST = $FF, $FF, $FF, $FF, $FF, $FF
//
// Pre-configured ARP packet
//
byte ARP = $00, $01 // HW TYPE
byte     = $08, $00 // PROTO TYPE
byte     = 6        // HLEN
byte     = 4        // PLEN
byte     = $00, $01 // OP
byte[6] localha
byte[4] localip  = 192,168,123,10
byte[6] remoteha
byte[4] remoteip = 192,168,123,1
//
// Max Ethernet frame size
//
const maxesize = 1518
word pkt, len
//
// Defines for ASM routines
//
asm equates
	!SOURCE	"vmsrc/plvmzp.inc"
end
//
// ASM utility functions
//
// Swap bytes in word
//
asm swab
	LDA	ESTKL,X
	LDY	ESTKH,X
	STA	ESTKH,X
	STY	ESTKL,X
	RTS
end
//
// SUM BE format
// sum(BUF, LEN)
//
export asm sum
	LDY	#$00
	LDA	ESTKL+1,X
	STY	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STY	ESTKH+1,X
	STA	SRCH
	LSR	ESTKH,X	; CONVERT BYTE LEN TO WORD LEN
	LDA	ESTKL,X
	ROR
	ADC	#$00
	STA	ESTKL,X
	BEQ	CHKLP
	INC     ESTKH,X
CHKLP	LDA	(SRC),Y
	PHA
	INY
	BNE	+
	INC	SRCH
+	LDA	(SRC),Y
	CLC
	ADC	ESTKH+1,X
	STA	ESTKH+1,X
	PLA
	ADC	ESTKL+1,X
	STA	ESTKL+1,X
	INY
	BNE	+
    	INC	SRCH
+	DEC	ESTKL,X
	BNE	CHKLP
	DEC	ESTKH,X
	BNE	CHKLP
	INX
	RTS
end
//
// DEBUG
//
def putln
    return putc($0D)
end
def putb(hexb)
    return call($FDDA, hexb, 0, 0, 0)
end
def puth(hex)
    return call($F941, hex >> 8, hex, 0, 0)
end
def puti(i)
  if i < 0; putc('-'); i = -i; fin
  if i < 10
    putc(i + '0')
  else
    puti(i / 10)
    putc(i % 10 + '0')
  fin
end
def putha(haptr)
    byte i
    
    for i = 0 to 4
        putb(haptr->[i]); putc(':')
    next
    return putb(haptr->[i])
end
def putip(ipptr)
    byte i
    
    for i = 0 to 2
        puti(ipptr->[i]); putc('.')
    next
    return puti(ipptr->[i])
end
def dumparp(packet)
    putha(packet + arp_senderha)
    putc('=')
    putip(packet + arp_senderip)
    putln
    putha(packet + arp_targha)
    putc('=')
    putip(packet + arp_targip)
    putln
end
def dumpfrm(packet, len)
    word i

    if len > 64
        len = 64
    fin
    len = len - 1
    for i = 0 to len
        if (i & 7) == 0
	    putln
        else
	    putc(' ')
	fin
	putb(^(packet+i))
    next
    putln
end

if modexec(@etherlib) == 0
    edrvr = modaddr(@etherlib)
    edrvr=>fillMAC(@localha)
    edrvr=>writeFrame(@BCAST, PAYLOAD_ARP, @ARP, t_arp)
    repeat; len = edrvr=>recvFrame(); until len or ^$C000 > 127
    if len
	pkt = heapalloc(len)
	if edrvr=>readFrame(pkt) == PAYLOAD_ARP
	    dumparp(pkt)
	else
            dumpfrm(pkt, len)
	fin
	heaprelease(pkt)
    fin
    ^$C010
fin
done