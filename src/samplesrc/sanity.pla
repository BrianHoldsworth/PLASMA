//
// SANE library test program
//
include "inc/cmdsys.plh"
include "inc/sane.plh"
//
// Test values
//
word iA, iB, iC, zero, fpEnv
byte xT[t_extended]
word decform = 0, 4
byte strA[29] = "8.5"
//
// My custom SANE exception handler
//
def myException(pstatus)
    sane:zpRestore()
    puts("Floating point exception:")
    if pstatus->8 & FBINVALID; puts(" INVALID"); fin
    if pstatus->8 & FBUFLOW;   puts(" UNDERFLOW"); fin
    if pstatus->8 & FBOFLOW;   puts(" OVERFLOW"); fin
    if pstatus->8 & FBDIVZER;  puts(" DIV_BY_ZERO"); fin
    if pstatus->8 & FBINEXACT; puts(" INEXACT"); fin
    putln
    sane:zpSave()
    return pstatus=>4
end

iA = 3
iB = 4
iC = -1
zero = 0
puts("SANE sanity test...\n")
sane.fpInit()
sane:zpSave()
sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FOADD, @xT, @iB) // Add int B to ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:zpRestore()
puti(iA); putc('+'); puti(iB); putc('='); puti(iC); putc('\n')
sane:zpSave()
sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FOSUB, @xT, @iB) // Sub int B from ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:zpRestore()
puti(iA); putc('-'); puti(iB); putc('='); puti(iC); putc('\n')
sane:zpSave()
sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FOMUL, @xT, @iB) // Mul int B by ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:zpRestore()
puti(iA); putc('*'); puti(iB); putc('='); puti(iC); putc('\n')
sane:zpSave()
sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FODIV, @xT, @iB) // Div int B into ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:zpRestore()
puti(iA); putc('/'); puti(iB); putc('='); puti(iC); putc('\n')
//
// Convert string to and from SANE
//
sane:zpSave()
sane:fpOp2(FFEXT|FOD2B, @xT, "8.5")
//sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FODIV, @xT, @iB) // Div int B into ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:fpOp3(FFEXT|FOB2D, @strA, @xT, @decform)
sane:zpRestore()
puts("8.5 / 4 = "); puts(@strA); putc('('); puti(iC); putc(')'); putln
//
// Hook custom HALT exception handler and divide by zero :-)
//
sane:zpSave()
sane:fpHalt = @myException
fpEnv = sane:fpOp0(FOGETENV)
//
// Enable all exceptions
//
sane:fpOp1(FOSETENV, fpEnv | FBINVALID | FBUFLOW | FBOFLOW | FBDIVZER | FBINEXACT)
sane:fpOp2(FFINT|FOZ2X, @xT, @iA) // Convert int A to ext T
sane:fpOp2(FFINT|FODIV, @xT, @zero) // Div ZERO into ext T
sane:fpOp2(FFINT|FOX2Z, @iC, @xT) // Convert ext T to int C
sane:zpRestore()
puti(iA); putc('/'); puti(zero); putc('='); puti(iC); putc('\n')
done
