const MODADDR     = $1000
;
; ROMCALL return register structure.
;
const acc         = 0
const xreg        = 1
const yreg        = 2
const preg        = 3
;
; SOS flags
;
const O_READ      = 1
const O_WRITE     = 2
const O_READ_WRITE = 3
;
; Pedefined functions.
;
predef home, gotoxy, viewport, crout, cout, prstr, cin, rdstr
predef syscall
predef markheap, allocheap, allocalignheap, releaseheap, availheap
predef memset, memcpy, xmemcpy
predef uword_isgt, uword_isge, uword_islt, uword_isle
predef execmod
;
; Standard Library exported functions.
;
byte stdlibstr[]  = "STDLIB"
byte clsstr[]     = "CLS"
byte gotoxystr[]  = "GOTOXY"
byte viewstr[]    = "VIEWPORT"
byte putcstr[]    = "PUTC"
byte putsstr[]    = "PUTS"
byte getcstr[]    = "GETC"
byte getsstr[]    = "GETS"
byte sysstr[]     = "SYSCALL"
byte hpmarkstr[]  = "HEAPMARK"
byte hpalignstr[] = "HEAPALLOCALIGN"
byte hpallocstr[] = "HEAPALLOC"
byte hprelstr[]   = "HEAPRELEASE"
byte hpavailstr[] = "HEAPAVAIL"
byte memsetstr[]  = "MEMSET"
byte memcpystr[]  = "MEMCPY"
byte uisgtstr[]   = "ISUGT"
byte uisgestr[]   = "ISUGE"
byte uisltstr[]   = "ISULT"
byte uislestr[]   = "ISULE"
byte execstr[]    = "EXEC"
word exports[]    = @clsstr,    @home
word              = @gotoxystr, @gotoxy
word		  = @viewstr,   @viewport
word		  = @putcstr,   @cout
word		  = @putsstr,   @prstr
word		  = @getcstr,   @cin
word		  = @getsstr,   @rdstr
word		  = @sysstr,    @syscall
word		  = @hpmarkstr, @markheap
word		  = @hpallocstr,@allocheap
word		  = @hpalignstr,@allocalignheap
word		  = @hprelstr,  @releaseheap
word		  = @memsetstr, @memset
word		  = @memcpystr, @memcpy
word              = @uisgtstr,  @uword_isgt
word              = @uisgestr,  @uword_isge
word              = @uisltstr,  @uword_islt
word              = @uislestr,  @uword_isle
word              = @execstr,   @execmod
word              = 0
word stdlibsym    = @exports     
;
; String pool.
;
byte console[]    = ".CONSOLE"
byte version[]    = "PLASMA 0.9\n"
byte freestr[]    = "MEM FREE:$"
byte errorstr[]   = "ERR:$"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte prefix[128]  = ""
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
;
; System variable.
;
word systemflags = 0
word heap
word symtbl, lastsym
word perr
word cmdptr
;
; CALL SOS
; SYSCALL(CMD, PARAMS)
;
asm syscall
	RTS
end
;
; SET MEMORY TO VALUE
; MEMSET(ADDR, SIZE, VALUE)
;
asm memset
	LDY     #$00
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	INC     ESTKL+1,X
	INC     ESTKH+1,X
SETMLP	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKL,X
	STA     (DST),Y
	INY
	BNE     +
	INC     DSTH
+	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKH,X
	STA     (DST),Y
	INY
	BNE     SETMLP
	INC     DSTH
	BNE     SETMLP
SETMEX	INX
	INX
	RTS
end
;
; COPY MEMORY
; MEMCPY(DSTADDR, SRCADDR, SIZE)
;
asm memcpy
	LDY	#$00
	LDA	ESTKL,X
	BNE 	+
	LDA	ESTKH,X
	BEQ	CPYMEX
+	LDA	ESTKL+2,X
	STA 	DSTL
	LDA	ESTKH+2,X
	STA 	DSTH
	LDA	ESTKL+1,X
	STA 	SRCL
	LDA	ESTKH+1,X
	STA 	SRCH
	CMP	DSTH
	BCC	REVCPY
	BNE	FORCPY
	LDA 	SRCL
	CMP	DSTL
	BCS	FORCPY
REVCPY				; REVERSE DIRECTION COPY
;	CLC
	LDA 	ESTKL,X
	ADC	DSTL
	STA	DSTL
	LDA	ESTKH,X
	ADC	DSTH
	STA	DSTH
	CLC
	LDA 	ESTKL,X
	ADC	SRCL
	STA	SRCL
	LDA	ESTKH,X
	ADC	SRCH
	STA	SRCH
	INC 	ESTKH,X
REVCPYLP
	LDA	DSTL
	BNE	+
	DEC	DSTH
+	DEC	DSTL
	LDA	SRCL
	BNE	+
	DEC	SRCH
+	DEC	SRCL
	LDA	(SRC),Y
	STA	(DST),Y
	DEC 	ESTKL,X
	BNE	REVCPYLP
	DEC	ESTKH,X
	BNE	REVCPYLP
	BEQ	CPYMEX
FORCPY	INC 	ESTKH,X
FORCPYLP
	LDA	(SRC),Y
	STA	(DST),Y
	INC	DSTL
	BNE	+
	INC	DSTH
+	INC	SRCL
	BNE	+
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	FORCPYLP
	DEC	ESTKH,X
	BNE	FORCPYLP
CPYMEX	INX
	INX
	RTS
end
;
; COPY FROM MAIN MEM TO EXT MEM.
;
; MEMXCPY(DIR, EXT, DST, SRC, SIZE)
;   DIR = 0 : COPY FROM MAIN TO EXT
;   DIR = 1 : COPY FROM EXT  TO MAIN
;
asm memxcpy
	RTS
end
;
; Unsigned word comparisons.
;
asm uword_isge
	LDY	#$00
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_isle
	LDY	#$00
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_isgt
	LDY	#$FF
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
asm uword_islt
	LDY	#$FF
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	RTS
end
;
; Addresses of internal routines.
;
asm interp
	DEX
	LDA	#<IINTERP
	STA	ESTKL,X
	LDA	#>IINTERP
	STA	ESTKH,X
	RTS
end
; 
; A DCI string is one that has the high bit set for every character except the last.
; More efficient than C or Pascal strings.
;
;def dcitos(dci, str)
;    byte len, c
;    len = 0
;    repeat
;        c = (dci).[len]
;        len = len + 1
;        (str).[len] = c & $7F
;    until !(c & $80)
;    ^str = len
;    return len
;end
asm dcitos
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(SRC),Y
	INY
	PHA
	AND	#$7F
	STA	(DST),Y
	PLA
	BMI	-
	TYA
	LDY	#$00
	STA	(DST),Y
	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
;def stodci(str, dci)
;    byte len, c
;    len = ^str
;    if len == 0
;        return
;    fin
;    c = toupper((str).[len]) & $7F
;    len = len - 1
;    (dci).[len] = c
;    while len
;    	c = toupper((str).[len]) | $80
;    	len = len - 1
;    	(dci).[len] = c
;    loop
;    return ^str
;end
asm stodci
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	INX
	LDY	#$00
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
asm toupper
	LDA     ESTKL,X
TOUPR	AND	#$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SEC
	SBC     #$20
+	STA     ESTKL,X
	RTS
end
;
; Module symbols are entered into the symbol table
; pre-pended with a '#' to differentiate them
; from normal symbols.
;
;def modtosym(mod, dci)
;    byte len, c
;    (dci).0 = '#'|$80
;    len = 0
;    repeat
;        c = (mod).[len]
;        len = len + 1
;        (dci).[len] = c
;    until !(c & $80)
;    return dci
;end
asm modtosym
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDA	ESTKL,X
	STA	ESTKL+1,X
	STA	DSTL
	LDA	ESTKH,X
	STA	ESTKH+1,X
	STA	DSTH
	INX
	LDY	#$00
	LDA	#'#'+$80
	STA	(DST),Y
-	LDA	(SRC),Y
	INY
	STA	(DST),Y
	AND	#$80
	BMI	-
	RTS
end
;
; Lookup routines.
;
;def lookuptbl(dci, tbl)
;    word match
;    while ^tbl
;        match = dci
;        while ^tbl == ^match
;            if !(^tbl & $80)
;                return (tbl):1
;            fin
;            tbl   = tbl   + 1
;            match = match + 1
;        loop
;        while (^tbl & $80)
;            tbl = tbl + 1
;        loop
;        tbl = tbl + 3
;    loop
;    return 0
asm lookuptbl
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(DST),Y
	BEQ	+
	CMP	(SRC),Y
	BNE	++
	INY
	AND	#$80
	BMI	-
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
+	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
++	LDY	#$00
--	LDA	(DST),Y
	INC	DSTL
	BNE	++
	INC	DSTH
++	AND	#$80
	BMI	--
	LDA	#$02
	CLC
	ADC	DSTL
	STA	DSTL
	TYA
	ADC	DSTH
	STA	DSTH
	BNE	-
end
;
; CONSOLE I/O
;
def cout(ch)
    if ch == $0D
        ch = $0A0D
    else
    fin
end
def cin
    byte ch
    return ch
end
def prstr(str)
    if (str).[^str] == $0D
        cout($0A)
    fin
end
def rdstr(prompt)
    cout(prompt)
    if (heap).[^heap] == $0D
        ^heap = ^heap - 1
    fin
    cout($0D)
    return heap
end
def home
    return cout(28)
end
def gotoxy(x, y)
end
def viewport(left, top, width, height)
end
def crout
    return cout($0D)
end
def prbyte(v)
    cout(hexchar[(v >> 4) & $0F])
    return cout(hexchar[v & $0F])
end
def prword(v)
    prbyte(v >> 8)
    return prbyte(v)
end
;
; CFFA1 routines
; FILE I/O
;
def getpfx(path)
    byte params[4]

    ^path    = 0
    params.0 = 2
    params:1 = path
    params.3 = 128
    perr     = syscall($C7, @params)
    return path
end
def setpfx(path)
    byte params[3]

    params.0 = 1
    params:1 = path
    perr     = syscall($C6, @params)
    return path
end
def volume(devname, volname, ttlblks, freblks)
    byte params[9]

    params.0 = 4
    params:1 = devname
    params:3 = volname
    params:5 = 0
    params:7 = 0
    perr     = syscall($C5, @params)
    *ttlblks = params:5
    *freblks = params:7
    return perr
end
def open(path, access)
    byte params[7]

    params.0 = 4
    params:1 = path
    params.3 = 0
    params:4 = @access
    params.6 = 1
    perr     = syscall($C8, @params)
    return params.3
end
def close(refnum)
    byte params[2]

    params.0 = 1
    params.1 = refnum
    perr     = syscall($CC, @params)
    return perr
end
def newline(refnum, set, char)
    byte params[4]

    params.0 = 1
    params.1 = refnum
    params.2 = set
    params.3 = char
    perr     = syscall($C9, @params)
    return perr
end
def read(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    perr     = syscall($CA, @params)
    return params:6
end
def write(refnum, buff, len)
    byte params[6]

    params.0 = 3
    params.1 = refnum
    params:2 = buff
    params:4 = len
    perr     = syscall($CB, @params)
    return perr
end
;
; Heap routines.
;
def availheap
    byte fp
    return @fp - heap
end
def allocheap(size)
    word addr
    addr = heap
    heap = heap + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def allocalignheap(size, pow2, freeaddr)
    word align, addr
    if freeaddr
        *freeaddr = heap
    fin
    align = (1 << pow2) - 1
    addr = (heap | align) + 1
    heap = addr + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def markheap
    return heap;
end
def releaseheap(newheap)
    heap = newheap;
    return @newheap - heap;
end
;
; DCI table routines,
;
;def dumptbl(tbl)
;    byte len
;
;    while ^tbl
;        len = 0
;        while ^tbl & $80
;            cout(^tbl)
;            tbl = tbl + 1
;            len = len + 1
;        loop
;        cout(^tbl)
;        tbl = tbl + 1
;        cout(':')
;        while len < 15
;            cout(' ')
;            len = len + 1
;        loop
;        cout('$')
;        prword(*tbl)
;        crout
;	tbl = tbl + 2
;    loop
;end
def addtbl(dci, val, last)
    while ^dci & $80
        ^*last = ^dci
        *last  = *last + 1
        dci    = dci   + 1
    loop
    ^*last = ^dci
    *last  = *last + 1
    **last = val
    *last  = *last + 2
    ^*last = 0
end
;
; Symbol table routines.
;
def lookupsym(sym)
    return lookuptbl(sym, symtbl)
end
def addsym(sym, addr)
    return addtbl(sym, addr, @lastsym);
end
;
; Module routines.
;
def lookupmod(mod)
    byte dci[17]
    return lookuptbl(modtosym(mod, @dci), symtbl)
end
def addmod(mod, addr)
    byte dci[17]
    return addtbl(modtosym(mod, @dci), addr, @lastsym)
end
def lookupextern(esd, index)
    word sym
    byte str[16]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if (esd).0 & $10 and (esd).1 == index
            return lookupsym(sym)
        fin
        esd = esd + 3
    loop
    prbyte(index)
    cout('?')
    crout
    return 0
end
def adddef(addr, deflast)
    word defentry
    defentry = *deflast
    *deflast = defentry + 5
    (defentry).0 = $20
    (defentry):1 = interp
    (defentry):3 = addr
    (defentry).4 = 0 ; null out next entry
    return defentry
end
def lookupdef(addr, deftbl)
    while (deftbl).0 == $20
        if (deftbl):3 == addr
	    ;prword(addr)
	    ;cout('>')
	    ;prword(deftbl)
	    ;crout
            return deftbl
        fin
        deftbl = deftbl + 5
    loop
    return 0
end
def loadmod(mod)
    word refnum, rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr, modaddr, modfix, modend
    word deftbl, deflast
    word moddep, rld, esd, sym
    byte str[16], filename[32]
    byte header[128]
    ;
    ; Read the RELocatable module header (first 128 bytes)
    ;
    dcitos(mod, @filename)
    refnum = open(@filename, O_READ)
    if refnum > 0
        rdlen   = read(refnum, @header, 128)
	modsize = header:0
	moddep  = @header.1
	defofst = modsize
        init    = 0
        if rdlen > 4 and header:2 == $DA7E ; DAVE = magic number :-)
            ;
            ; This is an EXTended RELocatable (data+bytecode) module.
            ;
	    systemflags = header:4 | systemflags
            defofst  = header:6
            defcnt   = header:8
            init     = header:10
            moddep   = @header.12
	    ;
	    ; Load module dependencies.
	    ;
            while ^moddep
                if !lookupmod(moddep)
		    if refnum
		        close(refnum)
			refnum = 0
		    fin
                    if loadmod(moddep) < 0
	      	        return perr
		    fin
                fin
                moddep = moddep + dcitos(moddep, @str)
            loop
	    ;
	    ; Init def table.
	    ;
	    deftbl   = allocheap(defcnt * 5 + 1)
	    deflast  = deftbl
	    ^deflast = 0
	    if !refnum
	        ;
		; Reset read pointer.
		;
	        refnum = open(@filename)
		rdlen  = read(refnum, @header, 128)
	    fin
        fin
	;
	; Alloc heap space for relocated module (data + bytecode).
	;
	moddep  = moddep  + 1
	modfix  = moddep  - @header.2 ; Adjust to skip header
	modsize = modsize - modfix
	rdlen   = rdlen   - modfix - 2
	modaddr = allocheap(modsize)
	memcpy(modaddr, moddep, rdlen)
	;
	; Read in remainder of module into memory for fixups.
	;
	addr = modaddr;
        repeat
            addr  = addr + rdlen
            rdlen = read(refnum, addr, 4096)
        until rdlen <= 0
        close(refnum)
	;
	; Apply all fixups and symbol import/export.
	;
        modfix   = modaddr - modfix
        bytecode = defofst + modfix - MODADDR
        modend   = modaddr + modsize
        rld      = modend  ; Re-Locatable Directory
        esd      = rld     ; Extern+Entry Symbol Directory
        while ^esd         ; Scan to end of ESD
            esd = esd + 4
	loop
        esd = esd + 1
        ;
        ; Run through the Re-Location Dictionary.
        ;
        while ^rld
            if ^rld == $02
	        ;
		; This is a bytcode def entry - add it to the def directory.
		;
                adddef((rld):1 - defofst + bytecode, @deflast)
            else
                addr = (rld):1 + modfix
                if uword_isge(addr, modaddr) ; Skip fixups to header
		    ;if uword_isge(addr, modend)
		    ;    cout('<')
		    ;    prword((rld):1)
		    ;    cout('>')
		    ;	prword(rld)
		    ;	crout
		    ;fin
                    if ^rld & $80 ; WORD sized fixup.
                        fixup = *addr
                    else	  ; BYTE sized fixup.
                        fixup = ^addr
                    fin
                    if ^rld & $10 ; EXTERN reference.
                        fixup = fixup + lookupextern(esd, (rld).3)
                    else	  ; INTERN fixup.
                        fixup = fixup + modfix - MODADDR
                        if uword_isge(fixup, bytecode)
                            ;
                            ; Bytecode address - replace with call def directory.
                            ;
                            fixup = lookupdef(fixup - bytecode + bytecode, deftbl)
                        fin
                    fin
                    if ^rld & $80 ; WORD sized fixup.
                        *addr = fixup
                    else	  ; BYTE sized fixup.
                        ^addr = fixup
                    fin
                fin
            fin
            rld = rld + 4
        loop
	;
        ; Run through the External/Entry Symbol Directory.
	;
        while ^esd
            sym = esd
            esd = esd + dcitos(esd, @str)
            if ^esd & $08
		;
                ; EXPORT symbol - add it to the global symbol table.
		;
                addr = (esd):1 + modfix - MODADDR
                if uword_isge(addr, bytecode)
		    ;
		    ; Use the def directory address for bytecode.
		    ;
                    addr = lookupdef(addr - bytecode + bytecode, deftbl)
                fin
                addsym(sym, addr)
            fin
            esd = esd + 3
        loop
	;
	; Free up end-of-module main memory.
	;
	releaseheap(modend)
    else
        perr = perr | 0x100
        return -perr
    fin
    ;
    ; Call init routine if it exists.
    ;
    if init
        return adddef(init - defofst + bytecode, @deflast)()
    fin
    return 0
end
;
; Command mode
;
def volumes
end
def catalog(optpath)
    byte path[64]
    byte refnum
    byte firstblk
    byte entrylen, entriesblk
    byte i, type, len
    word entry, filecnt

    if ^optpath
        memcpy(@path, optpath, ^optpath + 1)
    else
        getpfx(@path)
        prstr(@path)
        crout()
    fin
    refnum = open(@path, O_READ)
    if perr
        return perr
    fin
    firstblk = 1
    repeat
        if read(refnum, heap, 512) == 512
            entry = heap + 4
            if firstblk
                entrylen   = (heap).$23
                entriesblk = (heap).$24
                filecnt    = (heap):$25
                entry      = entry + entrylen
            fin
            for i = firstblk to entriesblk
                type = ^entry
                if type <> 0
                    len = type & $0F
                    ^entry = len
                    prstr(entry)
                    if type & $F0 == $D0 ; Is it a directory?
                        cout('/')
                        len = len + 1
		    elsif (entry).$10 == $FF
		        cout('-')
			len = len + 1
		    elsif (entry).$10 == $FE
		        cout('+')
			len = len + 1
                    fin
                    for len = 19 - len downto 0
                        cout(' ')
                    next
                    filecnt = filecnt - 1
                fin
                entry = entry + entrylen
            next
            firstblk = 0
        else
            filecnt = 0
        fin
    until filecnt == 0
    close(refnum)
    crout()
    return 0
end
def stripchars(strptr)
    while ^strptr and ^(strptr + 1) <> ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
    return ^strptr
end
def stripspaces(strptr)
    while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)
    byte i

    for i = 1 to ^strptr
        if (strptr)[i] == ' '
	    ^strptr = i - 1
	    return
	fin
    next
end
def parsecmd(strptr)
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
def execmod(modfile)
    byte moddci[17]
    word saveheap, savesym, saveflags
  
    if stodci(modfile, @moddci)
        saveheap  = heap
	savesym     = lastsym
	saveflags   = systemflags
	^lastsym    = 0
	perr        = loadmod(@moddci)
	systemflags = saveflags
	lastsym     = savesym
	heap        = saveheap
    fin
end

;
; Get heap start
;
heap = *$0006
;
; Print some startup info.
;
prstr(@version)
prstr(@freestr)
prword(availheap)
crout
;
; Init symbol table.
;
symtbl   = allocheap($200)
lastsym  = symtbl
^lastsym = 0
stodci(@stdlibstr, heap)
addmod(heap, 1)
while *stdlibsym
    stodci((stdlibsym):0, heap)
    addsym(heap, (stdlibsym):2)
    stdlibsym = stdlibsym + 4
loop
;
; Handle commands.
;
while 1
    prstr(getpfx(@prefix))
    cmdptr = rdstr($BA)
    if ^cmdptr
        when toupper(parsecmd(cmdptr))
            is 'Q'
	        ; reboot()
	    is 'C'
	        catalog(cmdptr)
	    is 'P'
	        setpfx(cmdptr)
	    is 'V'
	        volumes()
	    is '+'
	        execmod(cmdptr)
	    otherwise
	        prstr(@huhstr)
        wend
        if perr
            prstr(@errorstr)
	    prbyte(perr)
	    perr = 0
        else
            prstr(@okstr)
        fin
	crout()
    fin
loop
done
