include "inc/cmdsys.plh"
include "inc/fileio.plh"
const AUXADDR = $E000 // Location of SANE on 128K //e or //c
struc t_diskinfo
    word codelen
    word codeaddr
end
struc t_codefile
    byte[16*t_diskinfo] diskinfo
    byte[16*8]          segname
    word[16]            segkind
    word[16]            textaddr
    word[16]            seginfo
end
//
// External interface to SANE libraries
//
predef fpInit(), uninit0(), uninit1(op, dst), uninit2(op, dst, src)
export word[7] sane = @fpInit, @uninit1, @uninit2, @uninit1, @uninit2, @uninit0, @uninit0
//
// Pointer to FP6502 entry
//
word fp6502
//
// PLASMA <-> SANE interface routines
//
asm equates
        !SOURCE "vmsrc/plvmzp.inc"
end
//
// Main memory FP6502 API
//
asm fpOp1(op, dst)#1
        LDA     ESTKH,X
        PHA
        LDA     ESTKL,X
        PHA
        LDA     ESTKH+1,X
        PHA
        LDA     ESTKL+1,X
        PHA
        INX
        STX     ESP
end
asm fixupFP1
        JSR     $FFFF
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
asm fpOp2(op, dst, src)#1
        LDA     ESTKH,X
        PHA
        LDA     ESTKL,X
        PHA
        LDA     ESTKH+1,X
        PHA
        LDA     ESTKL+1,X
        PHA
        LDA     ESTKH+2,X
        PHA
        LDA     ESTKL+2,X
        PHA
        INX
        INX
        STX     ESP
end
asm fixupFP2
        JSR     $FFFF
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
//
// AUX memory FP6502 API
//
asm xfpOp1(op, dst)#1
        LDA     ESTKL+1,X
        STA     $02FE
        LDA     ESTKH+1,X
        STA     $02FF
        LDY     ESTKL,X
        LDA     ESTKH,X
        INX
        STX     ESP
        PHP
        SEI
        STA     $C009       ; SELECT ALTZP
        BIT     $C083       ; R/W LC BANK2
        BIT     $C083
        PHA
        TYA
        PHA
        LDA     $02FF
        PHA
        LDA     $02FE
        PHA
        JSR     $E000
        STA     $C008       ; BACK TO MAINZP
        PLP
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
asm xfpOp2(op, dst, src)#1
        LDA     ESTKL+2,X
        STA     $02FC
        LDA     ESTKH+2,X
        STA     $02FD
        LDA     ESTKL+1,X
        STA     $02FE
        LDA     ESTKH+1,X
        STA     $02FF
        LDY     ESTKL,X
        LDA     ESTKH,X
        INX
        INX
        STX     ESP
        PHP
        SEI
        STA     $C009       ; SELECT ALTZP
        BIT     $C083       ; R/W LC BANK2
        BIT     $C083
        PHA
        TYA
        PHA
        LDA     $02FF
        PHA
        LDA     $02FE
        PHA
        LDA     $02FD
        PHA
        LDA     $02FC
        PHA
        JSR     $E000
        STA     $C008       ; BACK TO MAINZP
        PLP
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
//
// Main memory ELEMS6502 API
//
asm elemsOp1(op, dst)#1
        LDA     ESTKH,X
        PHA
        LDA     ESTKL,X
        PHA
        LDA     ESTKH+1,X
        PHA
        LDA     ESTKL+1,X
        PHA
        INX
        STX     ESP
end
asm fixupEL1
        JSR     $FFFF
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
asm elemsOp2(op, dst, src)#1
        LDA     ESTKH,X
        PHA
        LDA     ESTKL,X
        PHA
        LDA     ESTKH+1,X
        PHA
        LDA     ESTKL+1,X
        PHA
        LDA     ESTKH+2,X
        PHA
        LDA     ESTKL+2,X
        PHA
        INX
        INX
        STX     ESP
end
asm fixupEL2
        JSR     $FFFF
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
//
// AUX memory ELEMS6502 API
//
asm xelemsOp1(op, dst)#1
        LDA     ESTKL+1,X
        STA     $02FE
        LDA     ESTKH+1,X
        STA     $02FF
        LDY     ESTKL,X
        LDA     ESTKH,X
        INX
        STX     ESP
        PHP
        SEI
        STA     $C009       ; SELECT ALTZP
        BIT     $C083       ; R/W LC BANK2
        BIT     $C083
        PHA
        TYA
        PHA
        LDA     $02FF
        PHA
        LDA     $02FE
        PHA
end
asm fixupXEL1
        JSR     $FFFF
        STA     $C008       ; BACK TO MAINZP
        PLP
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
asm xelemsOp2(op, dst)#1
        LDA     ESTKL+2,X
        STA     $02FC
        LDA     ESTKH+2,X
        STA     $02FD
        LDA     ESTKL+1,X
        STA     $02FE
        LDA     ESTKH+1,X
        STA     $02FF
        LDY     ESTKL,X
        LDA     ESTKH,X
        INX
        INX
        STX     ESP
        PHP
        SEI
        STA     $C009       ; SELECT ALTZP
        BIT     $C083       ; R/W LC BANK2
        BIT     $C083
        PHA
        TYA
        PHA
        LDA     $02FF
        PHA
        LDA     $02FE
        PHA
        LDA     $02FD
        PHA
        LDA     $02FC
        PHA
end
asm fixupXEL2
        JSR     $FFFF
        STA     $C008       ; BACK TO MAINZP
        PLP
        TXA
        LDX     ESP
        STA     ESTKL,X
        STY     ESTKH,X
        RTS
end
asm zpSave#1
        LDY     #$33
-       LDA     $00,Y
end
asm fixupZPS
        STA     $FFFF,Y
        DEY
        BPL     -
        DEX
        RTS
end
asm zpRestore#1
        LDY     #$33
end
asm fixupZPR
-       LDA     $FFFF,Y
        STA     $00,Y
        DEY
        BPL     -
end
asm zpNop#1
        DEX
        RTS
end
asm auxmove(dst, src, len)#0
        LDA     ESTKL+2,X
        STA     $02FA
        LDA     ESTKH+2,X
        STA     $02FB
        LDA     ESTKL+1,X
        STA     $02FC
        LDA     ESTKH+1,X
        STA     $02FD
        LDA     ESTKL,X
        STA     $02FE
        CLC
        BEQ     +
        SEC
+       LDA     ESTKH,X
        ADC     #$00
        STA     $02FF
        INX
        INX
        INX
        STX     ESP
        PHP
        SEI
        STA     $C009       ; SELECT ALTZP
        BIT     $C083       ; R/W LC BANK2
        BIT     $C083
        LDA     $02FA       ; DST ADDRESS
        STA     $42
        LDA     $02FB
        STA     $43
        LDA     $02FC       ; SRC ADDRESS
        STA     $3C
        LDA     $02FD
        STA     $3D
        LDY     #$00
-       LDA     ($3C),Y
        STA     ($42),Y
        INY
        BNE     +
        INC     $3D
        INC     $43
+       DEC     $02FE
        BNE     -
        DEC     $02FF
        BNE     -
        STA     $C008       ; SELECT MAINZP
        PLP
        LDX     ESP
        RTS
end
//
// Utility test routines
//
//def prbyte(h)#0
//    putc('$')
//    call($FDDA, h, 0, 0, 0)
//end
//def prword(h)#0
//    putc('$')
//    call($F941, h >> 8, h, 0, 0)
//end
//def putname(pchr)#0
//    byte c
//
//    for c = 0 to 7
//        putc(pchr->[c])
//    next
//end
//def putln#0
//    putc('\n')
//end
//def dumpheader(phdr)#0
//    byte i
//
//    puts("Seg Info\n")
//    for i = 0 to 15
//        if (phdr + i * t_diskinfo)=>codelen
//            prword((phdr + i * t_diskinfo)=>codelen)
//            putc(':')
//            prword((phdr + i * t_diskinfo)=>codeaddr)
//            putc('=')
//            putname(phdr + i * 8 + segname)
//            putc(',')
//            prword((phdr + segkind)=>[i])
//            putc(',')
//            prword((phdr + textaddr)=>[i])
//            putc(',')
//            prword((phdr + seginfo)=>[i])
//            putln
//        fin
//    next
//    putname(phdr + $01F4); putln
//end
//
// Fix-up external references and local relocations
//
def fixup(base, list)
    word len
    byte listcnt

    //puts("Reloc = "); prword(list); putln
    if *list <> $0101
        //puts("Reloc table not found!\n")
        return list
    fin
    list = list - 10
    //
    // External reference fixup (only have fp6502 in our case)
    //
    len  = *list
    list = list - 2
    //puts("Extern list len = "); prword(len); putln; getc
    while len
        //puts(" *"); prword(list - *list); putln
        *(list - *list) = fp6502
        list = list - 2
        len--
    loop
    //
    // Internal relocation
    //
    len  = *list
    list = list - 2
    //puts("Reloc list len = "); prword(len); putln; getc
    while len
        //puts(" *"); prword(list - *list); putln
        *(list - *list) = *(list - *list) + base
        list = list - 2
        len--
    loop
    return list
end
//
// Linker Information that we don't need
//
//def resolve(base, pli)
//    byte fixups
//    word basend
//
//    puts("LinkInfo "); prword(pli); putc(':'); putln
//    basend = preloc
//    while ^pli
//        putname(pli); putc(':')
//        prword(pli=>8); putc(' ')
//        prword(pli=>10); putc(' ')
//        prword(pli=>12); putc(' ')
//        prword(pli=>14); putln
//        fixups = 0
//        if pli=>8 == $0002
//            fixups = pli=>12
//        fin
//        pli = pli + 16
//        while fixups
//            *(base + *pli) = fp6502
//            pli = pli + 2
//            fixups--
//        loop
//    loop
//end
//
// Load Pascal CODE file
//
def loadcode(codefile)
    byte ref
    word pcode, seglen

    //puts(codefile); puts(":\n")
    pcode = 0
    ref   = open(codefile, sysbuf)
    if ref
        pcode = heapmark
        read(ref, pcode, 512)
        //dumpheader(pcode)
        //putname(pcode + segname + 8); putc('='); prword(pcode); putln
        seglen = read(ref, pcode, (pcode + t_diskinfo)=>codeaddr)
        close(ref)
        if !fp6502 and ^MACHID & $30 == $30
            seglen = fixup(AUXADDR, pcode + seglen - 2) - pcode
            auxmove(AUXADDR, pcode, seglen)
            pcode = AUXADDR
        else
            heaprelease(fixup(pcode, pcode + seglen - 2)) // Set heap to beginning of relocation list
        fin
    fin
    return pcode
end
//
// Load ELEMS6502 library
//
def loadElems
    word elems

    elems = loadcode("ELEMS.CODE")
    if !elems
        puts("ELEMS library not found.\n")
        return 0
    fin
    if fp6502 == AUXADDR
        (@fixupXEL1)=>1 = elems
        (@fixupXEL2)=>1 = elems
        sane[3] = @xelemsOp1
        sane[4] = @xelemsOp2
    else
        (@fixupEL1)=>1 = elems
        (@fixupEL2)=>1 = elems
        sane[3] = @elemsOp1
        sane[4] = @elemsOp2
    fin
    return 1
end
//
// Don't load ELEMS6502 until referenced
//
def elemsLoad1(op, dst)#1
    if loadElems
        return sane[3](op, dst)
    fin
    return -1
end
def elemsLoad2(op, src, dst)#1
    if loadElems
        return sane[4](op, src, dst)
    fin
    return -1
end
//
// Load SANE library and fixup function pointers
//
def fpInit()
    word fpzpsave

    fp6502 = loadcode("FP6502.CODE")
    if !fp6502
        puts("SANE library not found.\n")
        return -1
    fin
    if fp6502 == AUXADDR
        //
        // Fixup AUX calls in interface routines
        //
        sane[1] = @xfpOp1
        sane[2] = @xfpOp2
        sane[5] = @zpNop
        sane[6] = @zpNop
    else
        //
        // Fixup MAIN calls in interface routines
        //
        fpzpsave       = heapalloc($0033)
        (@fixupZPS)=>1 = fpzpsave
        (@fixupZPR)=>1 = fpzpsave
        (@fixupFP1)=>1 = fp6502
        (@fixupFP2)=>1 = fp6502
        sane[1] = @fpOp1
        sane[2] = @fpOp2
        sane[5] = @zpSave
        sane[6] = @zpRestore
    fin
    sane[3] = @elemsLoad1
    sane[4] = @elemsLoad2
end
//
// Uninitialized placeholders of API
//
def uninit
    puts("SANE not initialized\n")
    return -1
end
def uninit0()
    return uninit
end
def uninit1(op, dst)
return uninit
end
def uninit2(op, dst, src)
return uninit
end
done
