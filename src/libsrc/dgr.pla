import cmdsys
	predef memset, memcpy, heapmark, heapalloc, heaprelease
	byte MACHID
	//
	// System flags: memory allocator screen holes.
	//
	const restxt1     = $0001
	const restxt2     = $0002
	const resxtxt1    = $0004
	const resxtxt2    = $0008
	const reshgr1     = $0010
	const reshgr2     = $0020
	const resxhgr1    = $0040
	const resxhgr2    = $0080
end
sysflags $000F	// Reserve all text pages
//
// Apple II hardware constants.
//
const showgraphics = $C050
const showtext     = $C051
const showfull     = $C052
const showmix      = $C053
const showpage1    = $C054
const showpage2    = $C055
const showlores    = $C056
const showhires    = $C057
const show40       = $C00C
const show80       = $C00D
const mapmain      = $C000
const mapaux       = $C001
const an3on        = $C05E
const an3off       = $C05F
const dis80        = $C07E
const ena80        = $C07F
const page1        = 0
const page2        = 1
//
// Screen row address arrays.
//
word[] dgr1rows     = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
word                = $0428,$04A8,$0528,$05A8,$0628,$06A8,$0728,$07A8
word                = $0450,$04D0,$0550,$05D0,$0650,$06D0,$0750,$07D0
word[] dgr2rows     = $0800,$0880,$0900,$0980,$0A00,$0A80,$0B00,$0B80
word                = $0828,$08A8,$0928,$09A8,$0A28,$0AA8,$0B28,$0BA8
word                = $0850,$08D0,$0950,$09D0,$0A50,$0AD0,$0B50,$0BD0
word[] dgrbuff      = @dgr1rows, @dgr2rows
//
// Color mapping.
//
byte[] evnclr = $00,$88,$11,$99,$22,$00,$33,$BB
byte[]        = $44,$CC,$55,$DD,$66,$EE,$77,$FF
byte[] oddclr = $00,$11,$22,$33,$44,$00,$66,$77
byte[]        = $88,$99,$AA,$BB,$CC,$DD,$EE,$FF

byte[] sprite1 = $0,$0,$5,$5,$5,$5,$0,$0
byte[]         = $0,$5,$A,$A,$A,$A,$5,$0
byte[]         = $5,$A,$F,$F,$F,$F,$A,$5
byte[]         = $5,$A,$F,$F,$F,$F,$A,$5
byte[]         = $5,$A,$F,$F,$F,$F,$A,$5
byte[]         = $5,$A,$F,$F,$F,$F,$A,$5
byte[]         = $0,$5,$A,$A,$A,$A,$5,$0
byte[]         = $0,$0,$5,$5,$5,$5,$0,$0

byte[] tile1 = $88,$11,$88,$11,$88,$11,$88,$11
byte[]       = $88,$11,$88,$11,$88,$11,$88,$11
byte[]       = $88,$11,$88,$11,$88,$11,$88,$11
byte[]       = $88,$11,$88,$11,$88,$11,$88,$11

asm dgrInc(buff)
!SOURCE	"vmsrc/plvmzp.inc"
GBASL	=	$26
GBASH	=	$27
GBASE	=	GBASL
end
//
// Plot pixel
//
asm dgrPlot(buff, x, y)
	; GET BUFFER ADDRESS
	STX	ESP
	LDA	ESTKL+2,X
	STA	SRCL
	LDA	ESTKH+2,X
	STA	SRCH
	LDA	ESTKL,X		; Y COORD
	AND	#$FE
	TAY
	LDA	(SRC),Y
	STA	GBASL
	INY
	LDA	(SRC),Y
	STA	GBASH
	LDA	ESTKL+1,X	; X COORD
	LSR	ESTKL,X
	LDX	$30		; COLOR
	PHP
	SEI
end
asm _dgrPlotPix
	JSR	$3000
	PLP
	LDX	ESP
	INX
	INX
	RTS
end
//
// Plot horizontal row of pixels
//
asm dgrHLin(buff, x1, x2, y)
	; GET BUFFER ADDRESS
	STX	ESP
	LDA	ESTKL+3,X
	STA	SRCL
	LDA	ESTKH+3,X
	STA	SRCH
	LDA	ESTKL,X		; Y COORD
	AND	#$FE
	TAY
	LDA	(SRC),Y
	STA	GBASL
	INY
	LDA	(SRC),Y
	STA	GBASH
	LDA	ESTKL+2,X	; X1 COORD
	LSR	ESTKL,X
	PHP
-	PLP
	PHP
	SEI
	LDX	$30		; COLOR
end
asm _dgrHLinPix
	JSR	$3000
	LDX	ESP
	INC	ESTKL+2,X	; X1 COORD
	LDA	ESTKL+2,X
	CMP	ESTKL+1,X	; X2 COORD
	BCC	-
	BEQ	-
	PLP
	INX
	INX
	INX
	RTS
end
//
// Plot horizontal row of pixels
//
asm dgrVLin(buff, x, y1, y2)
	; GET BUFFER ADDRESS
	STX	ESP
	LDA	ESTKL+3,X
	STA	SRCL
	LDA	ESTKH+3,X
	STA	SRCH
	LDA	ESTKL+1,X	; Y1 COORD
-	AND	#$FE
	TAY
	LDA	(SRC),Y
	STA	GBASL
	INY
	LDA	(SRC),Y
	STA	GBASH
	LDA	ESTKL+1,X
	LSR
	LDA	ESTKL+2,X	; X COORD
	LDX	$30		; COLOR
	PHP
	SEI
end
asm _dgrVLinPix
	JSR	$3000
	PLP
	LDX	ESP
	INC	ESTKL+1,X	; Y1 COORD
	LDA	ESTKL+1,X
	CMP	ESTKL,X		; Y2 COORD
	BCC	-
	BEQ	-
	INX
	INX
	INX
	RTS
end
//
// Plot horizontal row of pixels
//
asm dgrBLT(buff, x1, x2, y1, y2, src)
	; GET BUFFER ADDRESS
	STX	ESP
	LDA	ESTKL,X		; SPRITE
	STA	SRCL
	LDA	ESTKH,X
	STA	SRCH
	LDA	ESTKL+5,X
	STA	DSTL
	LDA	ESTKH+5,X
	STA	DSTH
	LDA	ESTKL+2,X	; Y1 COORD
	STA	ESTKH+2,X	; Y COORD
-	CMP	#48
	BCS	+++
	AND	#$FE
	TAY
	LDA	(DST),Y
	STA	GBASL
	INY
	LDA	(DST),Y
	STA	GBASH
	LDA	ESTKL+4,X	; X1 COORD
	STA	ESTKH+4,X
--	CMP	#80
	BCS	++
	STA	TMP
	LDA	ESTKH+2,X	; Y COORD
	LSR
	LDY	#$00
	LDA	(SRC),Y
	INC	SRCL
	BNE	+
	INC	SRCH
+	TAX
	BEQ	++
	LDA	TMP
	PHP
	SEI
end
asm _dgrBLTPix
	JSR	$4000
	PLP
++	LDX	ESP
	INC	ESTKH+4,X	; X COORD
	LDA	ESTKH+4,X
	CMP	ESTKL+3,X	; X2 COORD
	BCC	--
	BEQ	--
+++	INC	ESTKH+2,X	; Y COORD
	LDA	ESTKH+2,X
	CMP	ESTKL+1,X	; Y2 COORD
	BCC	-
	BEQ	-
	INX
	INX
	INX
	INX
	INX
	RTS
end
//
// Internal set pixel routine
//
asm _dgrSetPix
	BCS	++
	; EVEN ROW
	LSR
	TAY
	BCS	+
end
asm _dgrSetEvnEvn
	; EVEN PIXEL
	LDA	$2000,X
	AND	#$0F
	STA	TMP
	JSR	$0100		; LDA AUX (DST),Y
	AND	#$F0
	ORA	TMP
	STA	$C005		; WRITE AUX MEM
	STA	(GBASE),Y
	STA	$C004		; WRITE MAIN MEM
	BCC	++++
end
asm _dgrSetEvnOdd
	; ODD PIXEL
+	LDA	$1000,X
	AND	#$0F
	STA	TMP
	LDA	(GBASE),Y
	AND	#$F0
	ORA	TMP
	STA	(GBASE),Y
	BCS	++++
	; ODD ROW
++	LSR
	TAY
	BCS	+++
end
asm _dgrSetOddEvn
	; EVEN PIXEL
	LDA	$2000,X
	AND	#$F0
	STA	TMP
	JSR	$0100		; LDA AUX (DST),Y
	AND	#$0F
	ORA	TMP
	STA	$C005		; WRITE AUX MEM
	STA	(GBASE),Y
	STA	$C004		; WRITE MAIN MEM
	BCC	++++
end
asm _dgrSetOddOdd
	; ODD PIXEL
+++	LDA	$1000,X
	AND	#$F0
	STA	TMP
	LDA	(GBASE),Y
	AND	#$0F
	ORA	TMP
	STA	(GBASE),Y
++++	RTS
end
asm auxRead
	STA	$C003		; READ AUX MEM
	LDA	(GBASE),Y
	STA	$C002		; READ MAIN MEM
	RTS
end
//
// Plot horizontal row of pixels
//
asm dgrTile(buff, x, y, src)
	; GET BUFFER ADDRESS
	STX	ESP
	LDA	ESTKL,X		; TILE
	STA	SRCL
	LDA	ESTKH,X
	STA	SRCH
	LDA	ESTKL+3,X
	STA	DSTL
	LDA	ESTKH+3,X
	STA	DSTH
	LDA	ESTKL+2,X	; X1 COORD
	CLC
	ADC	#$08
	STA	ESTKH+2,X	; X2 COORD
	LDA	ESTKL+1,X	; Y1 COORD
	STA	TMPL		; Y COORD
	CLC
	ADC	#$08
	STA	ESTKH+1,X	; Y2 COORD
	LDA	TMPL		; Y COORD
-	CMP	#48
	BCS	+++
	AND	#$FE
	TAY
	LDA	(DST),Y
	STA	GBASL
	INY
	LDA	(DST),Y
	STA	GBASH
	LDA	ESTKL+2,X	; X1 COORD
	STA	TMPH		; X COORD
--	CMP	#80
	BCS	++
	LSR
	TAY
	PHP
	SEI
	LDX	#$00
	LDA	(SRC,X)
	INC	SRCL
	BNE	+
	INC	SRCH
+	STA	$C005		; WRITE AUX MEM
	STA	(GBASE),Y
	STA	$C004		; WRITE MAIN MEM
	LDA	(SRC,X)
	INC	SRCL
	BNE	+
	INC	SRCH
+	STA	(GBASE),Y
	PLP
	LDX	ESP
++	INC	TMPH		; X COORD
	INC	TMPH		; X COORD
	LDA	TMPH
	CMP	ESTKH+2,X	; X2 COORD
	BCC	--
+++	INC	TMPL		; Y COORD
	INC	TMPL		; Y COORD
	LDA	TMPL
	CMP	ESTKH+1,X	; Y2 COORD
	BCC	-
	INX
	INX
	INX
	RTS
end
//
// Wait for VLB
//
asm vlbWait
	DEX
-	LDA	$C019
	BMI	-
-	LDA	$C019
	BPL	-
	RTS
end
//
// Set double lores graphics
//
def dgrMode
	^showlores
	^showfull
	^showgraphics
	^showpage1
	^ena80  = 0
	^show80 = 0
//	^mapaux = 0
	^an3on
end
//
// Set text mode
//
def txtMode
	^showtext
	^showpage1
	^ena80    = 0
	^show40   = 0
	^^mapmain = 0
	^an3on
end
//
// Set color for cear & plot routines
//
def dgrColor(clr)
	^$30 = clr & $0F
end
//
// Clear the buffer
//
def dgrClear(buff, clr)
	byte y
	
	^$30 = clr & $0F
	for y = 0 to 47
		dgrHLin(buff, 0, 79, y)
	next
end
def dgrFill(buff, tile)
	byte x, y
	
	for y = 0 to 47 step 8
		for x = 0 to 79 step 8
			dgrTile(buff, x, y, tile)
		next
	next
end
//
// Test routine
//
def dgrTest
	byte i, j
	
	dgrMode
	^showpage2
	^$C010
	j = 0
	while ^$C000 < 128
		//dgrClear(dgrbuff[1], j)
		j++
		if j > 40
			j = 0
		fin
		dgrFill(dgrbuff[1], @tile1)
		dgrBLT(dgrbuff[1], 20, 27, j, j + 7, @sprite1)
		for i = 0 to 47
			dgrColor(i)
			dgrPlot(dgrbuff[1], i, i)
		next
	loop
	^$C010
	txtMode
end

// Assembly fixups
_dgrPlotPix:1 = @_dgrSetPix
_dgrHLinPix:1 = @_dgrSetPix
_dgrVLinPix:1 = @_dgrSetPix
_dgrBLTPix:1  = @_dgrSetPix
_dgrSetEvnEvn:1 = @evnclr
_dgrSetEvnOdd:1 = @oddclr
_dgrSetOddEvn:1 = @evnclr
_dgrSetOddOdd:1 = @oddclr
// Put read AUX mem routine in scary location
memcpy($0100, @auxRead, 9)
dgrTest
done
