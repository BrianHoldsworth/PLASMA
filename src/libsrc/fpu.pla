//
// SANE stack-based Floating Point Unit library
//
include "inc/cmdsys.plh"
include "inc/sane.plh"
include "inc/fpstr.plh"
//
// External interface to FPU library
//
predef reset, pushInt, pushSgl, pushDbl, pushExt, pushStr
predef        pullInt, pullSgl, pullDbl, pullExt, pullStr
predef        loadInt, loadSgl, loadDbl, loadExt, loadStr
predef        storInt, storSgl, storDbl, storExt, storStr
predef        shiftUp, shiftDown, rotateUp, rotateDown, dup, swap, clear
predef        add, sub, mul, div, rem
predef        neg, abs, trunc, round, sqrt, square
export word fpu = @reset
word = @pushInt, @pushSgl, @pushDbl, @pushExt, @pushStr
word = @pullInt, @pullSgl, @pullDbl, @pullExt, @pullStr
word = @loadInt, @loadSgl, @loadDbl, @loadExt, @loadStr
word = @storInt, @storSgl, @storDbl, @storExt, @storStr
word = @shiftUp, @shiftDown, @rotateUp, @rotateDown, @dup, @swap, @clear
word = @add, @sub, @mul, @div, @rem
word = @neg, @abs, @trunc, @round, @sqrt, @square
//
// FP Stack
//
byte stack[t_extended*4]
word stackRegs[4]
//
// Stack manipulation routines
//
def rotateUp
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
end
def rotateDown
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[1], stackRegs[2], stackRegs[3], stackRegs[0]
end
def shiftUp
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    memset(stackRegs[0], 0, t_extended)
end
def shiftDown
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[1], stackRegs[2], stackRegs[3], stackRegs[0]
    memcpy(stackRegs[3], stackRegs[2], t_extended)
end
def dup
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    memcpy(stackRegs[0], stackRegs[1], t_extended)
end
def swap
    byte temp[t_extended]
    memcpy(temp,         stackRegs[1], t_extended)
    memcpy(stackRegs[1], stackRegs[0], t_extended)
    memcpy(stackRegs[0], temp,         t_extended)
end
def clear
    memset(stackRegs[0], 0, t_extended)
end
//
// Stack access
//
def pushInt(pInt)
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    sane:zpSave()
    sane:fpOp2(FFINT|FOZ2X, stackRegs[0], pInt)
    return sane:zpRestore()
end
def pullInt(pInt)
    sane:zpSave()
    sane:fpOp2(FFINT|FOX2Z, pInt, stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def loadInt(pInt, reg)
    sane:zpSave()
    sane:fpOp2(FFINT|FOZ2X, stackRegs[reg & $03], pInt)
    return sane:zpRestore()
end
def storInt(pInt, reg)
    sane:zpSave()
    sane:fpOp2(FFINT|FOX2Z, pInt, stackRegs[reg & $03])
    return sane:zpRestore()
end
def pushSgl(pSgl)
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    sane:zpSave()
    sane:fpOp2(FFSGL|FOZ2X, stackRegs[0], pSgl)
    return sane:zpRestore()
end
def pullSgl(pSgl)
    sane:zpSave()
    sane:fpOp2(FFSGL|FOX2Z, pSgl, stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def loadSgl(pSgl, reg)
    sane:zpSave()
    sane:fpOp2(FFSGL|FOZ2X, stackRegs[reg & $03], pSgl)
    return sane:zpRestore()
end
def storSgl(pSgl, reg)
    sane:zpSave()
    sane:fpOp2(FFSGL|FOX2Z, pSgl, stackRegs[reg & $03])
    return sane:zpRestore()
end
def pushDbl(pDbl)
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    sane:zpSave()
    sane:fpOp2(FFDBL|FOZ2X, stackRegs[0], pDbl)
    return sane:zpRestore()
end
def pullDbl(pDbl)
    sane:zpSave()
    sane:fpOp2(FFDBL|FOX2Z, pDbl, stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def loadDbl(pDbl, reg)
    sane:zpSave()
    sane:fpOp2(FFDBL|FOZ2X, stackRegs[reg & $03], pDbl)
    return sane:zpRestore()
end
def storDbl(pDbl, reg)
    sane:zpSave()
    sane:fpOp2(FFDBL|FOX2Z, pDbl, stackRegs[reg & $03])
    return sane:zpRestore()
end
def pushExt(pExt)
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    sane:zpSave()
    sane:fpOp2(FFEXT|FOZ2X, stackRegs[0], pExt)
    return sane:zpRestore()
end
def pullExt(pExt)
    sane:zpSave()
    sane:fpOp2(FFEXT|FOX2Z, pExt, stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def loadExt(pExt, reg)
    sane:zpSave()
    sane:fpOp2(FFEXT|FOZ2X, stackRegs[reg & $03], pExt)
    return sane:zpRestore()
end
def storExt(pExt, reg)
    sane:zpSave()
    sane:fpOp2(FFEXT|FOX2Z, pExt, stackRegs[reg & $03])
    return sane:zpRestore()
end
def pushStr(pStr)
    stackRegs[0], stackRegs[1], stackRegs[2], stackRegs[3] = stackRegs[3], stackRegs[0], stackRegs[1], stackRegs[2]
    sane:zpSave()
    str2ext(pStr, stackRegs[0])
    return sane:zpRestore()
end
def pullStr(pStr, intdigits, fracdigits, format)
    sane:zpSave()
    ext2str(stackRegs[0], pStr, intdigits, fracdigits, format)
    sane:zpRestore()
    return shiftDown
end
def loadStr(pStr, reg)
    sane:zpSave()
    str2ext(pStr, stackRegs[reg])
    return sane:zpRestore()
end
def storStr(pStr, intdigits, fracdigits, format, reg)
    sane:zpSave()
    ext2str(stackRegs[reg], pStr, intdigits, fracdigits, format)
    return sane:zpRestore()
end
//
// Basic math operations
//
def add
    sane:zpSave()
    sane:fpOp2(FFEXT|FOADD, stackRegs[1], stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def sub
    sane:zpSave()
    sane:fpOp2(FFEXT|FOSUB, stackRegs[1], stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def mul
    sane:zpSave()
    sane:fpOp2(FFEXT|FOMUL, stackRegs[1], stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def div
    sane:zpSave()
    sane:fpOp2(FFEXT|FODIV, stackRegs[1], stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def rem
    sane:zpSave()
    sane:fpOp2(FFEXT|FOREM, stackRegs[1], stackRegs[0])
    sane:zpRestore()
    return shiftDown
end
def neg#1
    sane:zpSave()
    sane:fpOp1(FFEXT|FONEG, stackRegs[0])
    return sane:zpRestore()
end
def abs
    sane:zpSave()
    sane:fpOp1(FFEXT|FOABS, stackRegs[0])
    return sane:zpRestore()
end
def trunc
    sane:zpSave()
    sane:fpOp1(FFEXT|FOTTI, stackRegs[0])
    return sane:zpRestore()
end
def round
    sane:zpSave()
    sane:fpOp1(FFEXT|FORTI, stackRegs[0])
    return sane:zpRestore()
end
def sqrt
    sane:zpSave()
    sane:fpOp1(FFEXT|FOSQRT, stackRegs[0])
    return sane:zpRestore()
end
def square
    sane:zpSave()
    sane:fpOp2(FFEXT|FOMUL, stackRegs[0], stackRegs[0])
    sane:zpRestore()
end
//
// Reset FPU and SANE
//
def reset
    byte i
    word zero

    zero = 0
    sane:fpInit()
    sane:zpSave()
    for i = 0 to 3
        stackRegs[i] = @stack[i * t_extended]
        sane:fpOp2(FFINT|FOZ2X, stackRegs[i], @zero)
    next
    return sane:zpRestore()
end
//
// Test code
//
def dumpStack#0
    byte r
    byte regStr[16]

    for r = 3 downto 0
        storStr(@regStr, 6, 4, 1, r)
        puts("  "); puti(r); putc(':'); puts(@regStr); putln
    next
end
//
// Run through some test cases
//
reset
dumpStack
puts("Push 2.0\n")
pushStr("2.0")
dumpStack
puts("Push 4.0\n")
pushStr("4.0")
dumpStack
puts("Add\n")
add
dumpStack
puts("Square\n")
square
dumpStack
puts("Sqrt\n")
sqrt
dumpStack
done
