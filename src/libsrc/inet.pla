import cmdsys
    predef syscall, call, getc, gets, putc, puts, putln
    predef memset, memcpy, modaddr, modexec
    predef heapmark, heapallocalign, heapalloc, heaprelease, heapavail
    byte MACHID
end
//
// Module don't free memory
//
const modkeep     = $2000
const modinitkeep = $4000
//
// Net object
//
struc t_inet
    word initIP
    word serviceIP
    word openUDP
    word sendUDP
    word closeUDP
    word listenTCP
    word connectTCP
    word sendTCP
    word closeTCP
    word setInterfaceIP
    word getInterfaceHA
    word setDNS
    word resolveIP
end
//
// External interface to net class. Must be first.
//
export byte[t_inet] iNet
//
// List of loadable network device drivers
//
byte netDrivers = "WIZNET"
byte            = "UTHERNET"
byte            = ""
word driver = @netDrivers
//
// DNS address
//
byte[4] dns

export def iNetInit
    //
    // Look for net hardware
    //
    while ^driver
        //puts(driver);putln
	if modexec(driver) >= 0
            break
	fin
	driver = driver + ^driver + 1
    loop
    if !^driver
        return 0
    fin
    //
    // Get an IP address
    //
    modexec("DHCP")
    return @iNet
end

def iNetSetDNS(ipptr)
    return memcpy(@dns, ipptr, 4)
end

def parseIP(ipstr, ipaddr)
    byte i
    word endstr
    
    endstr = ipstr + ^ipstr
    for i = 0 to 3
	ipstr = ipstr + 1
        while ^ipstr >= '0' and ^ipstr <= '9' and ipstr <= endstr
	    ipaddr->[i] = ipaddr->[i] * 10 + ^ipstr - '0'
	    ipstr = ipstr + 1
	loop
	if ^ipstr <> '.' and ipstr < endstr
	    return 0
	fin
    next
    return i == 3
end

def iNetResolve(namestr, ipaddr)
    ipaddr=>0 = 0
    ipaddr=>2 = 0
    if not parseIP(namestr, ipaddr)
        //
	// Query Domain Name Server for address
	//
    fin
    return 1
end

//
// Fill iNet 
iNet:initIP    = @iNetInit
iNet:setDNS    = @iNetSetDNS
iNet:resolveIP = @iNetResolve

done
