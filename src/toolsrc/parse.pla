//
// Alebraic op to stack op
//
def push_op(op, prec)#0
    if opsp == 16; exit_err("Op stack overflow"); fin
    opstack[opsp]   = op
    precstack[opsp] = prec
    opsp++
end
def pop_op
    opsp--
    if opsp < 0; exit_err("Op stack underflow"); fin
    return opstack[opsp]
end
def tos_op
    if opsp < 0
        return 0
    fin
    return opstack[opsp]
end
def tos_op_prec(tos)
    if opsp < tos
        return 100
    fin
    return precstack[opsp]
end
def push_val(value, size, type)#0
    if valsp == 16; exit_err("Eval stack overflow"); fin
    valstack[valsp]  = value
    sizestack[valsp] = size
    typestack[valsp] = type
    valsp++
end
def pop_val#3
    valsp--
    if valsp < 0; exit_err("Eval stack underflow"); fin
    return valstack[valsp], sizestack[valsp], typestack[valsp]
end
//
// Constant expression parsing
//
def calc_binaryop(op)#0
    word val1, val2
    byte size1, size2, type1, type2

    val2, size2, type2 = pop_val
    val1, size1, type1 = pop_val
    if type1 <> CONST_TYPE and type2 <> CONST_TYPE; exit_err(@bad_cnst); fin
    when op
        is MUL_TKN
            val1 = val1 * val2
            break
        is DIV_TKN
            val1 = val1 / val2
            break
        is MOD_TKN
            val1 = val1 % val2
            break
        is ADD_TKN
            val1 = val1 + val2
            break
        is SUB_TKN
            val1 = val1 - val2
            break
        is SHL_TKN
            val1 = val1 << val2
            break
        is SHR_TKN
            val1 = val1 >> val2
            break
        is AND_TKN
            val1 = val1 & val2
            break
        is OR_TKN
            val1 = val1 | val2
            break
        is EOR_TKN
            val1 = val1 ^ val2
            break
        otherwise
            exit_err(@bad_cnst)
    wend
    if size2 > size1; size1 = size2; fin
    push_val(val1, size1, type1)
end
def parse_constterm
    when scan
        is OPEN_PAREN_TKN
            parse_constexpr
            if token <> CLOSE_PAREN_TKN; exit_err(@no_close_paren); fin
            return TRUE
        is ID_TKN
        is INT_TKN
        is CHR_TKN
        is STR_TKN
            return TRUE
    wend
    return FALSE
end
def parse_constval
    byte mod, type, size
    word idptr, ctag, value

    mod = 0
    while not parse_constterm
        when token
            is SUB_TKN
                mod = mod | 1; break
            is COMP_TKN
                mod = mod | 2; break
            is LOGIC_NOT_TKN
                mod = mod | 4; break
            is AT_TKN
                mod = mod | 8; break
            is ADD_TKN
                break
            otherwise
                return FALSE
        wend
    loop
    when token
        is CLOSE_PAREN_TKN
            break
        is STR_TKN
            size  = tknlen - 1
            value = constval
            type  = STR_TYPE
            if mod; exit_err(@bad_op); fin
            break
        is CHR_TKN
            size  = 1
            value = constval
            type  = CONST_TYPE
            break
        is INT_TKN
            size  = 2
            value = constval
            type  = CONST_TYPE
            break
        is ID_TKN
            size  = 2
            idptr = id_lookup(tknptr, tknlen)
            type = idptr->idtype
            if type & ADDR_TYPE
                if mod <> 8; exit_err(@bad_cnst); fin
                type = CONSTADDR_TYPE
            fin
            value = idptr=>idval
            break
        otherwise
            return FALSE
    wend
    if mod & 1
        value = -value
    fin
    if mod & 2
        value = ~value
    fin
    if mod & 4
        value = !value
    fin
    push_val(value, size, type)
    return TRUE
end
def parse_constexpr#3
    byte prevmatch, matchop, i
    word optos

    matchop  = 0
    optos    = opsp
    repeat
        prevmatch = matchop
        matchop   = 0
        if parse_constval
            matchop = 1
            scan
            for i = 0 to bops_tblsz
                if token == bops_tbl[i]
                    matchop = 2
                    if bops_prec[i] >= tos_op_prec(optos)
                        calc_binaryop(pop_op)
                    fin
                    push_op(token, bops_prec[i])
                    break
                fin
            next
        fin
    until matchop <> 2
    if matchop == 0 and prevmatch == 0; return 0; fin
    if matchop == 0 and prevmatch == 2; exit_err(@missing_op); fin
    while optos < opsp
        calc_binaryop(pop_op)
    loop
    return pop_val
end
def parse_const(valptr)
    word idptr

    when scan
        is CHR_TKN
        is INT_TKN
            *valptr = constval
            break
        is ID_TKN
            idptr = id_lookup(tknptr, tknlen)
            if idptr->idtype & CONST_TYPE
                *valptr = idptr=>idval
                break
            fin
        otherwise
            return 0
    wend
    return CONST_TYPE
end
//
// Normal expression parsing
//
def parse_list#2
    byte listdepth, stackdepth
    word listseq

    listseq   = NULL
    listdepth = 0
    repeat
        listseq, stackdepth = parse_expr(listseq)
        listdepth = listdepth + stackdepth
    until not listseq or token <> COMMA_TOKEN
    return listseq, listdepth
end
def parse_value(codeseq, rvalue)#2
    byte cfnparms, cfnvals, stackdepth, deref, type, operation
    word optos, idptr, value, const_offset
    word uopseq, valseq, idxseq

    deref      = rvalue
    optos      = opsp
    type       = 0
    value      = 0
    cfnparms   = 0
    cfnvals    = 1
    stackdepth = 1
    uopseq     = NULL
    valseq     = NULL
    idxseq     = NULL
    //
    // Parse pre-ops
    //
    operation = TRUE
    repeat
        when scan
            is NEG_TKN
            is COMP_TKN
            is LOGIC_NOT_TKN
                uopseq = gen_uop(uopseq, token);
            is ADD_TKN
                if not rvalue; exit_err("Invalid op for LVALUE"); fin
                break
            is BPTR_TKN
                deref++
                type = type | BPTR_TYPE
                break
            is WPTR_TKN
                deref++
                type = type | WPTR_TYPE
                break
            is AT_TKN
                deref--
                if not deref; exit_err("Invalid ADDRESS-OF"); fin
                break
            otherwise
                operation = FALSE
        wend
    until not operation
    //
    // Determine terminal type
    //
    when token
        is ID_TKN
            idptr = id_lookup(tknptr, tknlen)
            if !idptr; return NULL, 0; fin
            if !(idptr->idtype); return NULL, 0; fin
            type  = type | idptr->idtype
            value = idptr=>idval
            if type & CONST_TYPE
                valseq = gen_const(NULL, value)
            else
                valseq = type & LOCAL_TYPE ?? gen_lcladr(NULL, value) :: gen_gbladr(NULL, value, type)
            fin
            if type & FUNC_TYPE
                cfnparms = idptr->funcparms
                cfnvals  = idptr->funcvals
            fin
            break
        is INT_TKN
        is CHR_TKN
            value  = constval
            type   = type | CONST_TYPE
            valseq = gen_const(NULL, value)
            break
        is STR_TKN
            codeseq = gen_str(codeseq, constval)
            scan
            return codeseq, stackdepth // Special case return
            break
        is OPEN_PAREN_TKN
            valseq, stackdepth = parse_expr(NULL)
            if scantoken <> CLOSE_PAREN_TOKEN; exit_err("Missing closing parenthesis"); fin
            break
        is DROP_TOKEN
            if rvalue; exit_err("DROP is LVALUE only"); fin
            codeseq = gen_drop(codeseq)
            scan
            return codeseq, 0 // Special case return
        is LAMBDA_TOKEN
            if not rvalue; return codeseq, 0; fin // Lambdas can't be LVALUES
            type   = type | CONST_TYPE
            value  = parse_lambda
            valseq = gen_gbladr(NULL, value, FUNC_TYPE)
            break
        otherwise
            if uopseq;  release_seq(uopseq);  fin
            if codeseq; release_seq(codeseq); fin
            return NULL, 0
    wend
    //
    // Parse post-ops
    //
    operation = TRUE
    repeat
        when scan
            is OPEN_PAREN_TKN
                //
                // Function call - parameters generate before call address
                //
                idxseq, value = parse_list(NULL)
                valseq = cat_seq(idxseq, valseq)
                if token <> CLOSE_PAREN_TKN; exit_err("Missing function closing parenthesis"); fin
                if type & FUNC_TYPE
                    if cfnparms <> value; exit_err("Parameter count mismatch"); fin
                else // Can't check parm count on function pointers
                    cfnparms = value
                fin
                if scan == POUND_TKN // Set function pointer return vals count - can't do this to regular function call
                    if type & FUNC_TYPE; exit_err("Overriding function return count"); fin
                    if not parse_const(@cfnvals); exit_err("Invalid def return value count"); fin
                else
                    scan_rewind(tokenstr)
                fin
                if type & (VAR_TYPE | PTR_TYPE) // !(type & (FUNC_TYPE | CONST_TYPE)))
                    valseq = gen_lw(valseq)
                    if deref; deref--; fin
                fin
                valseq     = gen_icall(valseq)
                stackdepth = stackdepth + cfnvals + cfnparms - value - 1
                cfnparms   = 0
                cfnvals    = 1
                type       = type & ~(FUNC_TYPE | VAR_TYPE)
                break
            is OPEN_BRACKET_TKN
                //
                // Array of arrays
                //
                if type & FUNC_TYPE // Function call dereference
                    valseq     = gen_icall(valseq)
                    stackdepth = stackdepth + cfnvals + cfnparms - 1
                    cfnparms   = 0
                    cfnvals    = 1
                    type       = type & ~FUNC_TYPE
                fin
                repeat
                    valseq, drop = parse_expr(valseq)
                    if token <> COMMA_TKN; break; fin
                    valseq = gen_idxw(valseq);
                    valseq = gen_lw(valseq);
                until FALSE
                if token <> CLOSE_BRACKET_TOKEN; exit_err("Missing closing bracket"); fin
                if type & (WPTR_TYPE | WORD_TYPE)
                    valseq = gen_idxw(valseq)
                    type = (type & PTR_TYPE) | WORD_TYPE
                else
                    valseq = gen_idxb(valseq)
                    type = (type & PTR_TYPE) | BYTE_TYPE
                fin
                break
            is PTRB_TKN
            is PTRW_TKN
                //
                // Structure member pointer
                //
                if type & FUNC_TYPE // Function call dereference
                    valseq     = gen_icall(valseq)
                    stackdepth = stackdepth + cfnvals + cfnparms - 1
                    cfnparms   = 0
                    cfnvals    = 1
                    type       = type & ~FUNC_TYPE
                elsif type & (VAR_TYPE | PTR_TYPE)
                    valseq = gen_lw(valseq) // Pointer dereference
                fin
                type = token == PTRB_TKN ?? BPTR_TYPE :: WPTR_TYPE
                if not parse_const(@const_offset)
                    if token == EOL_TKN or token == CLOSE_PAREN_TKN; exit_err("Syntax"); fin
                    scan_rewind(tokenstr) // Setting type override for following operations
                elsif const_offset <> 0
                    valseq = gen_const(valseq, const_offset) // Structure member pointer
                    valseq = gen_op(valseq, ADD_TOKEN)
                fin
                break
            is DOT_TKN
            is COLON_TKN
                //
                // Structure member offset
                //
                if type & FUNC_TYPE // Function call dereference
                    valseq     = gen_icall(valseq)
                    stackdepth = stackdepth + cfnvals + cfnparms - 1
                    cfnparms   = 0
                    cfnvals    = 1
                    type       = type & ~FUNC_TYPE
                fin
                if type & (VAR_TYPE | CONST_TYPE)
                    type = token == DOT_TOKEN ?? BYTE_TYPE :: WORD_TYPE
                else
                    type = token == DOT_TOKEN ?? BPTR_TYPE : :WPTR_TYPE
                fin
                if not parse_const(@const_offset)
                    if token == EOL_TOKEN or token == CLOSE_PAREN_TOKEN; exit_err("Syntax"); fin
                    scan_rewind(tokenstr) // Setting type override for following operations
                elsif const_offset <> 0
                    valseq = gen_const(valseq, const_offset) // Structure member offset
                    valseq = gen_op(valseq, ADD_TKN)
                fin
                break
            otherwise
                operation = FALSE
        wend
    until not operation
    //
    // Resolve outstanding dereference pointer loads
    //
    while deref > rvalue
        deref--
        if type & FUNC_TYPE
            valseq     = gen_icall(valseq)
            stackdepth = stackdepth + cfnvals + cfnparms - 1
            cfnparms   = 0
            cfnvals    = 1
            type       = type & ~FUNC_TYPE;
        elsif type & VAR_TYPE
            valseq = gen_lw(valseq)
        fin
    loop
    if deref
        if type & FUNC_TYPE
            valseq     = gen_icall(valseq)
            stackdepth = stackdepth + cfnvals + cfnparms - 1
            type       = type & ~FUNC_TYPE
        elsif type & (BYTE_TYPE | BPTR_TYPE)
            valseq = gen_lb(valseq)
        elsif type & (WORD_TYPE | WPTR_TYPE)
            valseq = gen_lw(valseq)
        fin
    fin
    //
    // Output pre-operations
    //
    valseq = cat_seq(valseq, uopseq)
    //
    // Wrap up LVALUE store
    //
    if not rvalue
        stackdepth--
        if type & (BYTE_TYPE | BPTR_TYPE)
            valseq = gen_sb(valseq)
        elsif type & (WORD_TYPE | WPTR_TYPE)
            valseq = gen_sw(valseq)
        else
            release_seq(valseq)
            return NULL, 0 // Function or const cannot be LVALUE, must be RVALUE
        fin
    fin
    return cat_seq(codeseq, valseq), stackdepth
end
def parse_expr(codeseq)#2
    byte stackdepth, matchdepth, stkdepth1, prevmatch, matchop, i
    word optos
    word tag_else, tag_endtri

    stackdepth = 0
    matchop    = 0
    optos      = opsp
    repeat
        prevmatch = matchop
        matchop   = 0
        codeseq, matchdepth = parse_value(codeseq, RVALUE)
        if matchdepth
            stackdepth = stackdepth + matchdepth
            matchop = 1
            for i = 0 to bops_tblsz
                if token == bops_tbl[i]
                    matchop = 2
                    if bops_prec[i] >= tos_op_prec(optos)
                        codeseq = gen_op(codeseq, pop_op)
                        stackdepth--
                    fin
                    push_op(token, bops_prec[i])
                    break
                fin
            next
        fin
    until matchop <> 2
    if matchop == 0 and prevmatch == 2; exit_err(@missing_op); fin
    while optos < opsp
        codeseq = gen_op(codeseq, pop_op)
        stackdepth--
    loop
    //
    // Look for ternary operator
    //
    if token == TERNARY_TOKEN
        if stackdepth <> 1; exit_err("Ternary op must evaluate to single value"); fin
        tag_else            = tag_new(BRANCH_TYPE)
        tag_endtri          = tag_new(BRANCH_TYPE)
        codeseq             = gen_brfls(codeseq, tag_else)
        codeseq, stkdepth1  = parse_expr(codeseq)
        if token <> TRIELSE_TOKEN; exit_err("Missing '::' in ternary op"); fin
        codeseq             = gen_brnch(codeseq, tag_endtri)
        codeseq             = gen_codetag(codeseq, tag_else)
        codeseq, stackdepth = parse_expr(codeseq)
        if stkdepth1 <> stackdepth; exit_err("Inconsistent value counts in ternary op"); fin
        codeseq = gen_codetag(codeseq, tag_endtri)
    fin
    return codeseq, stackdepth
end
def parse_set(codeseq)
    word setptr, rseq, setseq[16]
    byte lparms, rparms, i, lambda_set

    lparms     = 0
    rparms     = 0
    lambda_set = lambda_cnt
    setptr     = tknptr
    memset(@setseq, 0, 16)
    repeat
        setseq[lparms], drop = parse_value(NULL, LVALUE)
        if not setseq[lparms]; break; fin
        lparms++
    until token <> COMMA_TKN
    if not lparms or token <> SET_TKN
        //
        // Not a set list - free everything up
        //
        tknptr = setptr
        scan_rewind(tknptr)
        while lparms
            lparms--
            release_seq(setseq[lparms])
        loop
        while lambda_cnt > lambda_set
            lambda_cnt--
            lambda_num--
            release_seq(lambda_seq[lambda_cnt])
        loop
        return NULL
    fin
    rseq, rparms = parse_list(NULL)
    if lparms > rparms; exit_err("Set value list underflow"); fin
    codeseq = cat_seq(codeseq, rseq)
    if lparms < rparms
        parse_warn("Silently dropping extra set values")
        for i = rparms - lparms downto 1
            codeseq = gen_drop(codeseq)
        next
    fin
    for i = lparms downto 1
        codeseq = cat_seq(codeseq, setseq[i])
    next
    return codeseq
end
def parse_stmnt
    byte type, elem_type, elem_size, i, cfnvals
    word seq, tag_prevbrk, tag_prevcnt, tag_else, tag_endif, tag_while, tag_wend
    word tag_repeat, tag_for, tag_choice, tag_of, idptr, addr, stepdir

    if token <> END_TKN and token <> DONE_TKN and token <> OF_TKN and token <> DEFAULT_TKN
        prevstmnt = token
    fin
    when token
        is IF_TKN
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err(@bad_expr); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1; cfnvals--; seq = gen_drop(seq); loop
            fin
            tag_else  = ctag_new
            tag_endif = ctag_new
            seq = gen_brfls(seq, tag_else)
            emit_seq(seq)
            repeat
                while parse_stmnt
                    nextln
                loop
                if token <> ELSEIF_TKN
                    break
                fin
                emit_branch(tag_endif)
                emit_ctag(tag_else)
                seq, cfnvals = parse_expr(NULL)
                if !seq; exit_err(@bad_expr); fin
                if cfnvals > 1
                    parse_warn("Expression value overflow")
                    while cfnvals > 1; cfnvals--; seq = gen_drop(seq); loop
                fin
                tag_else = ctag_new
                seq = gen_brfls(seq, tag_else)
                emit_seq(seq)
            until FALSE
            if token == ELSE_TKN
                emit_branch(tag_endif)
                emit_ctag_(tag_else)
                scan
                while parse_stmnt
                    nextln
                loop
                emit_ctag(tag_endif)
            else
                emit_ctag(tag_else)
                emit_ctag(tag_endif)
            fin
            if token <> FIN_TKN; exit_err("Missing IF/FIN"); fin
            break
        is WHILE_TKN
            tag_while   = ctag_new
            tag_wend    = ctag_new
            tag_prevcnt = cont_tag
            cont_tag    = tag_while
            tag_prevbrk = break_tag
            break_tag   = tag_wend
            emit_ctag(tag_while)
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err(@bad_expr); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
            fin
            seq = gen_brfls(seq, tag_wend)
            emit_seq(seq)
            while parse_stmnt
                nextln
            loop
            if token <> LOOP_TKN; exit_err("Missing WHILE/LOOP"); fin
            emit_branch(tag_while)
            emit_ctag(tag_wend)
            break_tag = tag_prevbrk
            cont_tag  = tag_prevcnt
            break
        is REPEAT_TKN
            tag_repeat  = ctag_new
            tag_prevbrk = break_tag
            break_tag   = ctag_new
            tag_prevcnt = cont_tag
            cont_tag    = ctag_new
            emit_ctag(tag_repeat)
            scan
            while parse_stmnt
                nextln
            loop
            if token <> UNTIL_TKN; exit_err("Mising REPEAT/UNTIL"); fin
            emit_ctag(cont_tag)
            cont_tag = tag_prevcnt
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err(@bad_expr); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1; cfnvals--; seq = gen_drop(seq); loop
            fin
            seq = gen_brfls(seq, tag_repeat)
            emit_seq(seq)
            emit_ctag(break_tag)
            break_tag = tag_prevbrk
            break
        is FOR_TKN
            stack_loop++
            tag_for     = ctag_new
            tag_prevcnt = cont_tag
            cont_tag    = tag_for
            tag_prevbrk = break_tag
            break_tag   = ctag_new
            if scan <> ID_TKN; exit_err("Missing FOR variable"); fin
            idptr = id_lookup(tknptr, tknlen)
            if idptr
                type  = idptr->idtype
                addr  = idptr=>idval
            else
                exit_err("Bad FOR variable")
            fin
            if scan <> SET_TKN; exit_err("Missing FOR ="); fin
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err(@bad_expr); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
            fin
            emit_ctag(tag_for)
            if type & LOCAL_TYPE
                type & BYTE_TYPE ?? emit_dlb(addr) :: emit_dlw(addr)
            else
                type & BYTE_TYPE ?? emit_dab(addr, 0) :: emit_daw(addr, 0)
            fin
            if token == TO_TKN
                stepdir = 1
            elsif token == DOWNTO_TKN
                stepdir = -1
            else
                exit_err("Missing FOR TO")
            fin
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err("Bad FOR TO expression"); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
            fin
            emit_seq(seq)
            stepdir > 0 ?? emit_brgt(break_tag) :: emit_brlt(break_tag)
            fin
            if token == STEP_TKN
                seq, cfnvals = parse_expr(NULL)
                if !seq; exit_err("Bad FOR STEP expression"); fin
                if cfnvals > 1
                    parse_warn("Expression value overflow")
                    while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
                fin
                emit_binaryop(stepdir > 0 ?? ADD_TKN :: SUB_TKN)
            else
                emit_unaryop(stepdir > 0 ?? INC_TKN :: DEC_TKN)
            fin
            while parse_stmnt
                nextln
            loop
            if token <> NEXT_TKN; exit_err("Missing FOR/NEXT"); fin
            emit_branch(tag_for)
            cont_tag = tag_prevcnt
            emit_ctag(break_tag)
            emit_drop
            break_tag = tag_prevbrk
            stack_loop--
            break
        is CASE_TKN
            stack_loop++
            tag_prevbrk = break_tag
            break_tag   = ctag_new
            tag_choice  = ctag_new
            tag_of      = ctag_new
            seq, cfnvals = parse_expr(NULL)
            if !seq; exit_err("Bad CASE expression"); fin
            if cfnvals > 1
                parse_warn("Expression value overflow")
                while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
            fin
            nextln
            while token <> ENDCASE_TKN
                when token
                    is OF_TKN
                        seq, cfnvals = parse_expr(NULL)
                        if !seq; exit_err("Bad FOR TO expression"); fin
                        if cfnvals > 1
                            parse_warn("Expression value overflow")
                            while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
                        fin
                        emit_brne(tag_choice)
                        emit_ctag(tag_of)
                        while parse_stmnt
                            nextln
                        loop
                        tag_of = ctag_new
                        if prevstmnt <> BREAK_TKN // Fall through to next OF if no break
                            emit_branch(tag_of)
                        fin
                        emit_ctag(tag_choice)
                        tag_choice = ctag_new
                        break
                    is DEFAULT_TKN
                        emit_ctag(tag_of)
                        tag_of = 0
                        scan
                        while parse_stmnt
                            nextln
                        loop
                        if token <> ENDCASE_TKN; exit_err("Bad WHEN OTHERWISE"); fin
                        break
                    is EOL_TKN
                        nextln
                        break
                    otherwise
                        exit_err("Bad WHEN")
                wend
            loop
            if (tag_of)
                emit_ctag(tag_of)
            fin
            emit_ctag(break_tag)
            emit_drop
            break_tag = tag_prevbrk
            stack_loop--
            break
        is BREAK_TKN
            if break_tag
                emit_branch(break_tag)
            else
                exit_err("BREAK outside FOR or WHEN")
            fin
            break
        is CONT_TKN
            if cont_tag
                emit_branch(cont_tag)
            else
                exit_err("CONTINUE outside FOR or WHEN")
            fin
            break
        is RETURN_TKN
            if infunc
                for i = 1 to stack_loop
                    emit_drop
                next
                seq, cfnvals = parse_expr(NULL)
                if !seq; exit_err("Bad CASE expression"); fin
                if cfnvals > infuncvals
                    exit_err("Too many return values")
                elsif cfnvals < infuncvals
                    parse_warn("Too few return values")
                    while cfnvals < infuncvals
                        cfnvals++
                        emit_const(0)
                    loop
                fin
                emit_leave
            else
                seq, cfnvals = parse_expr(NULL)
                if !seq
                    emit_const(0)
                elsif cfnvals > 1
                    parse_warn("Expression value overflow")
                    while cfnvals > 1;cfnvals--; seq = gen_drop(seq); loop
                fin
                emit_ret
            break
        is EOL_TKN
            return TRUE
        is ELSE_TKN
        is ELSEIF_TKN
        is FIN_TKN
        is LOOP_TKN
        is UNTIL_TKN
        is NEXT_TKN
        is OF_TKN
        is DEFAULT_TKN
        is ENDCASE_TKN
        is END_TKN
        is DONE_TKN
        is DEF_TKN
            return FALSE
        otherwise
            rewind(tknptr)
            seq = parse_set(NULL)
            if seq
                emit_seq(seq)
            else
                idptr = tokenptr
                seq, cfnvals = parse_value(NULL, RVALUE)
                if seq
                    if token == INC_TKN or token == DEC_TKN
                        emit_seq(seq)
                        emit_unaryop(token)
                        scanrewind(idptr)
                        seq, drop = parse_value(NULL, LVALUE)
                        emit_seq(seq)
                    elsif token <> SET_TKN
                        while cfnvals > 1
                            seq = cat_seq(seg, gen_drop(NULL))
                            cfnvals--
                        loop
                        emit_seq(seq)
                    else
                        exit_err("Invalid LVALUE")
                    fin
                else
                    exit_err("Syntax")
                fin
            fin
    wend
    return scan == EOL_TKN
end
def parse_var(type, basesize)#0
    byte consttype, constsize, idlen
    word idptr, constval, arraysize, size

    idlen = 0
    size  = 1
    if scan == ID_TKN
        idptr = tknptr
        idlen = tknlen
        if scan == OPEN_BRACKET_TKN
            size, constsize, consttype = parse_constexpr
            if token <> CLOSE_BRACKET_TKN; exit_err(@no_close_bracket); fin
            scan
        fin
    fin
    size = size * basesize
    if token == SET_TKN
        if type & (EXTERN_TYPE | LOCAL_TYPE); exit_err(@no_local_init); fin
        if idlen
            iddata_add(idptr, idlen, type, 0)
        fin
        constval, constsize, consttype = parse_constexpr
        arraysize = emit_data(type, consttype, constval, constsize)
        while token == COMMA_TKN
            constval, constsize, consttype = parse_constexpr
            arraysize = arraysize + emit_data(type, consttype, constval, constsize)
        loop
        iddata_size(PTR_TYPE, size, arraysize)
    elsif idlen
        if infunc
            idlocal_add(idptr, idlen, type, size)
        else
            iddata_add(idptr, idlen, type, size)
        fin
    fin
end
def parse_struc#0
    byte strucid[16]
    byte type, idlen, struclen, constsize, consttype
    word size, offset, idstr

    struclen = 0
    if scan == ID_TKN
        struclen = tknlen
        if struclen > 16
            struclen = 16
        fin
        for idlen = 0 to struclen
            strucid[idlen] = ^(tknptr + idlen)
        next
    fin
    offset = 0
    while nextln == BYTE_TKN or token == WORD_TKN or token == EOL_TKN
        if token <> EOL_TKN
            size = 1
            type = token == BYTE_TKN ?? BYTE_TYPE :: WORD_TYPE
            if scan == OPEN_BRACKET_TKN
                size, constsize, consttype = parse_constexpr
                if token <> CLOSE_BRACKET_TKN; exit_err(@no_close_bracket); fin
                scan
            fin
            repeat
                idlen = 0;
                if token == ID_TKN
                    idstr = tknptr
                    idlen = tknlen
                    if scan == OPEN_BRACKET_TKN
                        size, constsize, consttype = parse_constexpr
                        if token <> CLOSE_BRACKET_TKN; exit_err(@no_close_bracket); fin
                        scan
                    fin
                fin
                if type & WORD_TYPE
                    size = size * 2
                fin
                if idlen
                    idconst_add(idstr, idlen, offset)
                fin
                offset = offset + size
            until token <> COMMA_TKN
        fin
    loop
    if struclen
        idconst_add(@strucid, struclen, offset)
    fin
    if token <> END_TKN; exit_err("Missing STRUC/END"); fin
    scan
end
def parse_vars(type)
    byte idlen, size
    word value, idptr

    when token
        is SYSFLAGS_TKN
            if type & (EXTERN_TYPE | LOCAL_TYPE); exit_err("SYSFLAGS must be global"); fin
            value, drop, drop = parse_constexpr
            emit_sysflags(value)
            break
        is CONST_TKN
            if scan <> ID_TKN; exit_err(@bad_cnst); fin
            idptr = tknptr
            idlen = tknlen
            if scan <> SET_TKN; exit_err(@bad_cnst); fin
            value, size, type = parse_constexpr
            idconst_add(idptr, idlen, value)
            break
        is STRUC_TKN
            parse_struc
            break
        is EXPORT_TKN
            if type & (EXTERN_TYPE | LOCAL_TYPE); exit_err("Cannot export local/imported variables"); fin
            type  = EXPORT_TYPE
            idstr = tokenptr
            if scan <> BYTE_TKN and token <> WORD_TKN // This could be an exported definition
                scan_rewind(idstr)
                scan
                return
            fin
            // Fall through to BYTE or WORD declaration
        is BYTE_TKN
        is WORD_TKN
            type = type | (token == BYTE_TKN ?? BYTE_TYPE :: WORD_TYPE)
            size = 1
            if scan == OPEN_BRACKET_TKN // Get basesize for data elements
              size, drop, drop = parse_constexpr
              if token <> CLOSE_BRACKET_TKN; exit_err(@no_close_bracket); fin
            else
                scan_rewind(tokenptr)
            fin
            if type & WORD_TYPE; size = size * 2; fin
            repeat; parse_var(type, size); until token <> COMMA_TKN
            break
        is PREDEF_TKN
            repeat
                if scan == ID_TKN
                    type     = type | PREDEF_TYPE
                    idstr    = tokenptr
                    idlen    = tokenlen
                    cfnparms = 0
                    cfnvals  = 1 // Default to one return value for compatibility
                    if scan == OPEN_PAREN_TKN
                        repeat
                            if scan == ID_TKN
                                cfnparms++
                                scan
                            fin
                        until token <> COMMA_TOKEN
                        if token <> CLOSE_PAREN_TKN; exit_err("Bad function parameter list"); fin
                        scan
                    fin
                    if token == POUND_TKN
                        if not parse_const(@cfnvals); exit_err("Invalid def return value count"); fin
                        scan
                    fin
                    idfunc_add(idstr, idlen, type, tag_new(type), cfnparms, cfnvals)
                else
                    exit_err("Bad function pre-declaration")
                fin
            until token <> COMMA_TKN
            break
        is EOL_TKN
            break
        otherwise
            return FALSE
    wend
    return TRUE
end
def parse_mods
    if token == IMPORT_TKN
        if scan <> ID_TKN; exit_err("Bad import definition"); fin
        emit_moddep(tokenstr, tokenlen)
        scan
        while parse_vars(EXTERN_TYPE); next_line(); loop
        if token <> END_TKN; exit_err("Missing IMPORT/END"); fin
        scan
    fin
    if token == EOL_TOKEN; return TRUE; fin
    emit_moddep(0, 0)
    return FALSE
end
def parse_lambda
    word func_tag
    byte cfnparms

    if not infunc; exit_err("Lambda functions only allowed inside definitions"); fin
    idlocal_save
    //
    // Parse parameters and return value count
    //
    cfnparms = 0
    if scan == OPEN_PAREN_TKN
        repeat
            if scan == ID_TKN
                cfnparms++
                idlocal_add(tokenstr, tokenlen, WORD_TYPE, 2)
                scan
            fin
        until token <> COMMA_TKN
        if token <> CLOSE_PAREN_TKN; exit_err("Bad function parameter list"); fin
    else
        exit_err("Missing parameter list in lambda function");
    fin
    expr = scanptr
    if scan_lookahead == OPEN_PAREN_TKN
        scan
        lambda_seq[lambda_cnt], drop = parse_list(NULL)
        if token <> CLOSE_PAREN_TKN; exit_error("Missing closing lambda function parenthesis"); fin
    else
        lambda_seq[lambda_cnt], drop = parse_expr(NULL)
        scan_rewind(tknptr)
    fin
    //
    // Build an anonymous ID string for the Lambda function
    //
    strcpy(lambda_id + lambda_cnt * 8, "_LAMB__")
    ^(lambda_id + lambda_cnt * 8 + 6) = (lambda_num >> 3) & 0x07 + '0'
    ^(lambda_id + lambda_cnt * 8 + 7) =  lambda_num       & 0x07 + '0'
    if idglobal_lookup(lambda_id + lambda_cnt * 8, 7) >= 0
        //
        // Lambda ID already exists (from failed scanning for '=')
        //
        func_tag = lambda_tag=>[lambda_cnt]
        idfunc_set(lambda_id + lambda_cnt * 8 + 1, 7, func_tag, 0, 0) // Override any predef type & tag
    else
        //
        // Creat new Lambda ID
        //
        func_tag               = ctag_new
        lambda_tag=>[lambda_cnt] = func_tag
        idfunc_add(lambda_id + lambda_cnt * 8 + 1, 7, func_tag, 0, 0)
    fin
    lambda_cnt++
    idlocal_restore
    return func_tag
end
def parse_defs
    byte cfnparms, cfnvals, type
    word func_tag, idptr

    type = DEF_TYPE
    if token == EXPORT_TKN
        if scan <> DEF_TKN; exit_err("Bad export definition"); fin
        type = type | EXPORT_TYPE
    fin
    if token == DEF_TKN
        if scan <> ID_TKN; exit_err(@bad_decl); fin
        lambda_cnt = 0
        cfnparms   = 0
        infuncvals = 1
        infunc     = TRUE
        idlocal_init
        if scan == OPEN_PAREN_TKN
            repeat
                if scan == ID_TKN
                    cfnparms++
                    idlocal_add(tknptr, tknlen, WORD_TYPE, 2)
                    scan
                fin
            until token <> COMMA_TKN
            if token <> CLOSE_PAREN_TKN; exit_err(@bad_decl); fin
            scan
        fin
        if token == POUND_TKN
            if not parse_const(@infuncvals); parse_error("Invalid def return value count"); fin
            scan
        fin
        idptr = idglobal_lookup(tknptr, tknlen)
        if idptr
            if not idptr->type & PREDEF_TYPE; exit_err("Mismatch function type"); fin
            if idptr->funcparms <> cfnparms or idptr->funcvals <> infuncvals; exit_err("Mismatch function params/return values"); fin
            emit_idfunc(idptr)
            func_tag = idptr=>idval
        else
            func_tag = ctag_new
            idfunc_add(tknptr, tknlen, func_tag, 0, 0, cfnparms, infuncvals)
        fin
        emit_ctag(func_tag)
        retfunc_tag = ctag_new
        while parse_vars(LOCAL_TYPE)
            nextln
        loop
        emit_enter(cfnparms)
        prevstmnt = 0
        while parse_stmnt
            nextln
        loop
        infunc = FALSE
        if token <> END_TKN; exit_err("Missing DEF/END"); fin
        scan
        if prevstmnt <> RETURN_TKN
            if infuncvals; parse_warn("No return values"); fin
            for cfnvals = infuncvals - 1 downto 0
                emit_const(0)
            emit_leave
        fin
        return TRUE
        while lambda_cnt
            lambda_cnt--
            emit_lambdafunc(lambda_tag[lambda_cnt], lambda_id + lambda_cnt * 8, lambda_cparams[lambda_cnt], lambda_seq[lambda_cnt])
        loop
    fin
    return token == EOL_TKN ?? TRUE :: FALSE
end
def parse_module
    idglobal_init
    idlocal_init
    srcref = fileio:open(@srcfile)
    if srcref
        fileio:newline(srcref, $7F, $0D)
        refnum    = srcref
        parsefile = @srcfile
        if nextln
            //
            // Compile module
            //
            while parse_vars
                nextln
            loop
            while parse_defs
                nextln
            loop
            framesize  = 0
            entrypoint = codeptr
            prevstmnt  = 0
            emit_enter(0)
            if token <> DONE_TKN
                while parse_stmnt
                    nextln
                loop
            fin
            if prevstmnt <> RETURN_TKN
                emit_const(0)
                emit_leave
            fin
            fileio:close(srcref)
            //dumpsym(idglobal_tbl, globals)
            return not parserr
        fin
    else
        puts("Error opening: "); puts(@srcfile); putln
    fin
    return FALSE
end
