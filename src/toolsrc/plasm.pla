//
// Data and text buffer constants
//
const machid        = $BF98
const iobuffer      = $0800
const databuff      = $0C00
const codebuff      = $A900
const codebuffsz    = $1000
//
// Compiler variables
//
//
// Tokens
//
const ID_TKN             = $D6 // V
const CHR_TKN            = $C3 // C
const INT_TKN            = $C9 // I
const STR_TKN            = $D3 // S
const EOL_TKN            = $02
const EOF_TKN            = $01
const ERR_TKN            = $00
//
//Ternary operand operators
//
const TERNARY_TOKEN      = $BF // ?
const TRIELSE_TOKEN      = $DF // _
//
// Binary operand operators
//
const SET_TKN            = $BD // =
const ADD_TKN            = $AB // +
const SUB_TKN            = $AD // -
const MUL_TKN            = $AA // *
const DIV_TKN            = $AF // /
const MOD_TKN            = $A5 // %
const OR_TKN             = $FC // |
const EOR_TKN            = $DE // ^
const AND_TKN            = $A6 // &
const SHR_TKN            = $D2 // R
const SHL_TKN            = $CC // L
const GT_TKN             = $BE // >
const GE_TKN             = $C8 // H
const LT_TKN             = $BC // <
const LE_TKN             = $C2 // B
const NE_TKN             = $D5 // U
const EQ_TKN             = $C5 // E
const LOGIC_AND_TKN      = $CE // N
const LOGIC_OR_TKN       = $CF // O
//
// Unary operand operators
//
const AT_TKN             = $C0 // @
const DOT_TKN            = $AE // .
const COLON_TKN          = $BA // :
const NEG_TKN            = $AD // -
const POUND_TKN          = $A3 // #
const COMP_TKN           = $FE // ~
const LOGIC_NOT_TKN      = $A1 // !
const BPTR_TKN           = $DE // ^
const WPTR_TKN           = $AA // *
const PTRB_TKN           = $D8 // X
const PTRW_TKN           = $D7 // W
const INC_TKN            = $C1 // A
const DEC_TKN            = $C4 // D
//
// Enclosure tokens
//
const OPEN_PAREN_TKN     = $A8 // (
const CLOSE_PAREN_TKN    = $A9 // )
const OPEN_BRACKET_TKN   = $DB // [
const CLOSE_BRACKET_TKN  = $DD // ]
//
// Misc. tokens
//
const COMMA_TKN          = $AC // ,
//const COMMENT_TKN        = $BB // //
const DROP_TKN           = $BB
//
// Keyword tokens
//
const CONST_TKN          = $80
const BYTE_TKN           = $81
const WORD_TKN           = $82
const IF_TKN             = $83
const ELSEIF_TKN         = $84
const ELSE_TKN           = $85
const FIN_TKN            = $86
const END_TKN            = $87
const WHILE_TKN          = $88
const LOOP_TKN           = $89
const CASE_TKN           = $8A
const OF_TKN             = $8B
const DEFAULT_TKN        = $8C
const ENDCASE_TKN        = $8D
const FOR_TKN            = $8E
const TO_TKN             = $8F
const DOWNTO_TKN         = $90
const STEP_TKN           = $91
const NEXT_TKN           = $92
const REPEAT_TKN         = $93
const UNTIL_TKN          = $94
const DEF_TKN            = $95
const STRUC_TKN          = $96
const SYSFLAGS_TKN       = $97
const DONE_TKN           = $98
const RETURN_TKN         = $99
const BREAK_TKN          = $9A
const CONT_TKN           = $9B
const PREDEF_TKN         = $9C
const IMPORT_TKN         = $9D
const EXPORT_TKN         = $9E
const INCLUDE_TKN        = $9F
//
// Types
//
const CONST_TYPE         = $01
const BYTE_TYPE          = $02
const WORD_TYPE          = $04
const VAR_TYPE           = $06 // (WORD_TYPE | BYTE_TYPE)
const FUNC_TYPE          = $08
const FUNC_CONST_TYPE    = $09
const ADDR_TYPE          = $0E // (VAR_TYPE | FUNC_TYPE)
const LOCAL_TYPE         = $10
const BPTR_TYPE          = $20
const WPTR_TYPE          = $40
const PTR_TYPE           = $60 // (BPTR_TYPE | WPTR_TYPE)
const XBYTE_TYPE         = $22 // (BPTR_TYPE | BYTE_TYPE)
const XWORD_TYPE         = $44 // (WPTR_TYPE | WORD_TYPE)
const CONSTADDR_TYPE     = $61 // (CONST_TYPE | PTR_TYPE)
const STR_TYPE           = $80
//
// Keywords
//
byte keywrds             = "IF",       IF_TKN
byte                     = "TO",       TO_TKN
byte                     = "IS",       OF_TKN
byte                     = "OR",       LOGIC_OR_TKN
byte                     = "FOR",      FOR_TKN
byte                     = "FIN",      FIN_TKN
byte                     = "DEF",      DEF_TKN
byte                     = "END",      END_TKN
byte                     = "AND",      LOGIC_AND_TKN
byte                     = "NOT",      LOGIC_NOT_TKN
byte                     = "BYTE",     BYTE_TKN
byte                     = "WORD",     WORD_TKN
byte                     = "ELSE",     ELSE_TKN
byte                     = "NEXT",     NEXT_TKN
byte                     = "WHEN",     CASE_TKN
byte                     = "LOOP",     LOOP_TKN
byte                     = "STEP",     STEP_TKN
byte                     = "DONE",     DONE_TKN
byte                     = "WEND",     ENDCASE_TKN
byte                     = "DROP",     DROP_TKN
byte                     = "CONST",    CONST_TKN
byte                     = "STRUC",    STRUC_TKN
byte                     = "ELSIF",    ELSEIF_TKN
byte                     = "WHILE",    WHILE_TKN
byte                     = "UNTIL",    UNTIL_TKN
byte                     = "BREAK",    BREAK_TKN
byte                     = "IMPORT",   IMPORT_TKN
byte                     = "EXPORT",   EXPORT_TKN
byte                     = "DOWNTO",   DOWNTO_TKN
byte                     = "REPEAT",   REPEAT_TKN
byte                     = "RETURN",   RETURN_TKN
byte                     = "PREDEF",   PREDEF_TKN
byte                     = "INCLUDE",  INCLUDE_TKN
byte                     = "CONTINUE", CONT_TKN
byte                     = "SYSFLAGS", SYSFLAGS_TKN
byte                     = "OTHERWISE",DEFAULT_TKN
byte                     = $FF
//
// Mathematical ops
//
const bops_tblsz = 17 // minus 1
byte[] bops_tbl // Highest precedence
byte                    = MUL_TKN, DIV_TKN, MOD_TKN
byte                    = ADD_TKN, SUB_TKN
byte                    = SHR_TKN, SHL_TKN
byte                    = AND_TKN
byte                    = EOR_TKN
byte                    = OR_TKN
byte                    = GT_TKN, GE_TKN, LT_TKN, LE_TKN
byte                    = EQ_TKN, NE_TKN
byte                    = LOGIC_AND_TKN
byte                    = LOGIC_OR_TKN
                        // Lowest precedence
byte[] bops_prec // Highest precedence
byte                    = 1, 1, 1
byte                    = 2, 2
byte                    = 3, 3
byte                    = 4
byte                    = 5
byte                    = 6
byte                    = 7, 7, 7, 7
byte                    = 8, 8
byte                    = 9
byte                    = 10
                                 // Lowest precedence
byte[16] opstack
byte[16] precstack
word opsp = 0
word[16] valstack
byte[16] sizestack
byte[16] typestack
word valsp = 0
//
// Symbol table variables
//
struc t_opseq
    byte code
    word val
    word tag
    word offsz
    byte type
    word nextop
end
const OPSEQNUM          = 200
const idglobal_tblsz    = 2048
const idlocal_tblsz     = 512
const idglobal_tbl      = $1600
const idlocal_tbl       = $1E00
const ctag_max          = 1024
const ctag_tbl          = $800
const idval             = 0
const idtype            = 2
const idname            = 3
const idrecsz           = 4
word globals            = 0
word datasize           = 0
word lastglobal
byte locals             = 0
word framesize          = 0
word lastlocal
const IS_RESOLVED       = $8000
const IS_RELATIVE       = $8000
const IS_CTAG           = $8000
const MASK_CTAG         = $7FFF
word codetag            = -1
word codeptr, entrypoint = 0
word modsysflags        = 0
byte lastop             = $FF
//
// Scanner variables
//
const inbuff            = $0200
const instr             = $01FF
word  scanptr           = @nullstr
byte  scanchr, token, tknlen
byte  parserrpos, parserr = 0
word  tknptr, parserrln
word  constval
word  lineno = 0
//
// Compiler output messages
//
byte dup_id[]               = "DUPLICATE IDENTIFIER"
byte undecl_id[]            = "UNDECLARED IDENTIFIER"
byte bad_cnst[]             = "BAD CONSTANT"
byte bad_struc[]            = "BAD STRUCTURE"
byte bad_offset[]           = "BAD STRUCT OFFSET"
byte bad_decl[]             = "BAD DECLARATION"
byte bad_op[]               = "BAD OPERATION"
byte bad_stmnt[]            = "BAD STATMENT"
byte bad_expr[]             = "BAD EXPRESSION"
byte bad_syntax[]           = "BAD SYNTAX"
byte local_overflw[]        = "LOCAL FRAME OVERFLOW"
byte global_sym_overflw[]   = "GLOBAL SYMBOL TABLE OVERFLOW"
byte local_sym_overflw[]    = "LOCAL SYMBOL TABLE OVERFLOW"
byte ctag_full[]            = "CODE LABEL OVERFLOW"
byte no_ctag_offst[]        = "CODE OFFSET NOT SUPPORTED"
byte no_close_paren[]       = "MISSING CLOSING PAREN"
byte no_close_bracket[]     = "MISSING CLOSING BRACKET"
byte missing_op[]           = "MISSING OPERAND"
byte no_fin[]               = "MISSING FIN"
byte no_loop[]              = "MISSING LOOP"
byte no_until[]             = "MISSING UNTIL"
byte no_done[]              = "MISSING DONE"
byte no_local_init[]        = "NO INITIALIZED LOCALS"
//
// ProDOS/SOS file references
//
byte refnum, srcref, incref
byte[32] srcfile
byte[32] incfile
word parsefile // Pointer to current file
word sysincbuf // System I/O buffer for include files
word srcline   // Saved source line number
//
// Parser variables
//
byte[128] strconst
byte infunc      = 0
byte stack_loop  = 0
byte prevstmnt   = 0
word retfunc_tag = 0
word break_tag   = 0
word cont_tag    = 0
predef parse_constexpr#3, parse_expr, parse_lambda

//=====================================
//
//           PLASMA Compiler
//
//=====================================

//
// Error handler
//
def parse_err(errstr)
    if !parserr
        parserr    = TRUE
        parserrln  = lineno - 1
        parserrpos = tknptr - inbuff
        puts(parsefile); putc('['); puti(lineno); putc(']'); putc(':'); puts(errstr); putln
        puts(instr)
        for i = parseerrpos-1 downto 0
            putc(' ')
        next
        puts("^\n")
    fin
    return ERR_TKN
end
//
// Include code to reduce size of this file
//
include "toolsrc/codegen.pla"
include "toolsrc/lex.pla"
include "toolsrc/parse.pla"
//
// Look at command line arguments and compile module
//
arg = argNext(argFirst)
if arg
    strcpy(@srcfile, arg)
    if parsemodule
        puts("Bytes compiled: "); puti(codeptr - codebuff); putln
    fin
else
    puts("Usage: +PLASM [srcfile]\n")
fin

done
